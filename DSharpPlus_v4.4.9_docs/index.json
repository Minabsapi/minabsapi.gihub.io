{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | DSharpPlus",
    "keywords": "API Reference Welcome to DSharpPlus API reference. To begin, select a namespace, then a class, from the table of contents on the left."
  },
  "articles/advanced_topics/buttons.html": {
    "href": "articles/advanced_topics/buttons.html",
    "title": "Buttons | DSharpPlus",
    "keywords": "Introduction Buttons are a feature in Discord based on the interaction framework appended to the bottom of a message which come in several colors. You will want to familarize yourself with the message builder as it and similar builder objects will be used throughout this article. With buttons, you can have up to five buttons in a row, and up to five (5) rows of buttons, for a maximum for 25 buttons per message. Furthermore, buttons come in two types: regular, and link. Link buttons contain a Url field, and are always grey. Buttons Continued Warning Component (Button) Ids on buttons should be unique, as this is what's sent back when a user presses a button. Link buttons do not have a custom id and do not send interactions when pressed. Buttons consist of five parts: Id Style Label Emoji Disabled The id of the button is a settable string on buttons, and is specified by the developer. Discord sends this id back in the interaction object. Non-link buttons come in four colors, which are known as styles: Blurple, Grey, Green, and Red. Or as their styles are named: Primary, Secondary, Success, and Danger respectively. How does one construct a button? It's simple, buttons support constructor and object initialization like so: var myButton = new DiscordButtonComponent( ButtonStyle.Primary, \"my_very_cool_button\", \"Very cool button!\", false, new DiscordComponentEmoji(\"😀\")); This will create a blurple button with the text that reads \"Very cool button!\". When a user pushes it, \"my_very_cool_button\" will be sent back as the @DSharpPlus.EventArgs.ComponentInteractionCreateEventArgs.Id property on the event. This is expanded on in the how to respond to buttons. The label of a button is optional if an emoji is specified. The label can be up to 80 characters in length. The emoji of a button is a partial emoji object, which means that any valid emoji is usable, even if your bot does not have access to it's origin server. The disabled field of a button is rather self explanatory. If this is set to true, the user will see a greyed out button which they cannot interact with. Adding buttons Note This article will use underscores in button ids for consistency and styling, but spaces are also usable. Adding buttons to a message is relatively simple. Simply make a builder, and sprinkle some content and the buttons you'd like. var builder = new DiscordMessageBuilder(); builder.WithContent(\"This message has buttons! Pretty neat innit?\"); Well, there's a builder, but no buttons. What now? Simply make a new @DSharpPlus.Entities.DiscordButtonComponent object and call @DSharpPlus.Entities.DiscordMessageBuilder.AddComponents* on the message builder. var myButton = new DiscordButtonComponent(ButtonStyle.Primary, \"my_custom_id\", \"This is a button!\"); var builder = new DiscordMessageBuilder() .WithContent(\"This message has buttons! Pretty neat innit?\") .AddComponents(myButton); Now you have a message with a button. Congratulations! It's important to note that @DSharpPlus.Entities.DiscordMessageBuilder.AddComponents* will create a new row with each call, so add everything you want on one row in one call! Buttons can be added in any order you fancy. Lets add 5 to demonstrate each color, and a link button for good measure. var builder = new DiscordMessageBuilder() .WithContent(\"This message has buttons! Pretty neat innit?\") .AddComponents(new DiscordComponent[] { new DiscordButtonComponent(ButtonStyle.Primary, \"1_top\", \"Blurple!\"), new DiscordButtonComponent(ButtonStyle.Secondary, \"2_top\", \"Grey!\"), new DiscordButtonComponent(ButtonStyle.Success, \"3_top\", \"Green!\"), new DiscordButtonComponent(ButtonStyle.Danger, \"4_top\", \"Red!\"), new DiscordLinkButtonComponent(\"https://some-super-cool.site\", \"Link!\") }); As promised, not too complicated. Links however are @DSharpPlus.Entities.DiscordLinkButtonComponent, which takes a URL as its first parameter, and the label. Link buttons can also have an emoji, like regular buttons. Lets also add a second row of buttons, but disable them, so the user can't push them all willy-nilly. builder.AddComponents(new DiscordComponent[] { new DiscordButtonComponent(ButtonStyle.Primary, \"1_top_d\", \"Blurple!\", true), new DiscordButtonComponent(ButtonStyle.Secondary, \"2_top_d\", \"Grey!\", true), new DiscordButtonComponent(ButtonStyle.Success, \"3_top_d\", \"Green!\", true), new DiscordButtonComponent(ButtonStyle.Danger, \"4_top_d\", \"Red!\", true), new DiscordLinkButtonComponent(\"https://some-super-cool.site\", \"Link!\", true) }); Practically identical, but now with true as an extra paremeter. This is the @DSharpPlus.Entities.DiscordButtonComponent.Disabled property. Produces a message like such: Well, that's all neat, but lets say you want to add an emoji. Being able to use any emoji is pretty neat, afterall. That's also very simple! var myButton = new DiscordButtonComponent( ButtonStyle.Primary, \"emoji_button\", null, false, new DiscordComponentEmoji(595381687026843651)); And you're done! Simply add that to a builder, and when you send, you'll get a message that has a button with a little Pikachu enjoying a lolipop. Adorable. Responding to button presses When any button is pressed, it will fire the @DSharpPlus.DiscordClient.ComponentInteractionCreated. In the event args, @DSharpPlus.EventArgs.ComponentInteractionCreateEventArgs.Id will be the id of the button you specified. There's also an @DSharpPlus.EventArgs.InteractionCreateEventArgs.Interaction property, which contains the interaction the event created. It's important to respond to an interaction within 3 seconds, or it will time out. Responding after this period will throw a @DSharpPlus.Exceptions.NotFoundException. With buttons, there are two new response types: @DSharpPlus.InteractionResponseType.DeferredMessageUpdate and @DSharpPlus.InteractionResponseType.UpdateMessage. Using @DSharpPlus.InteractionResponseType.DeferredMessageUpdate lets you create followup messages via the followup message builder. The button will return to being in it's 'dormant' state, or it's 'unpushed' state, if you will. You have 15 minutes from that point to make followup messages. Responding to that interaction looks like this: client.ComponentInteractionCreated += async (s, e) => { await e.Interaction.CreateResponseAsync(InteractionResponseType.DeferredMessageUpdate); // Do things.. // } If you would like to update the message when a button is pressed, however, you'd use @DSharpPlus.InteractionResponseType.UpdateMessage instead, and pass a @DSharpPlus.Entities.DiscordInteractionResponseBuilder with the new content you'd like. client.ComponentInteractionCreated += async (s, e) => { await e.Interaction.CreateResponseAsync( InteractionResponseType.UpdateMessage, new DiscordInteractionResponseBuilder() .WithContent(\"No more buttons for you >:)\")); } This will update the message, and remove all the buttons. Nice. Interactivity Along with the typical @DSharpPlus.Interactivity.InteractivityExtension.WaitForMessageAsync*and @DSharpPlus.Interactivity.InteractivityExtension.WaitForReactionAsync* methods provided by interactivity, there are also button implementations as well. More information about how interactivity works can be found in the interactivity article. Since buttons create interactions, there are also two additional properties in the configuration: @DSharpPlus.Interactivity.InteractivityConfiguration.ResponseBehavior @DSharpPlus.Interactivity.InteractivityConfiguration.ResponseMessage @DSharpPlus.Interactivity.InteractivityConfiguration.ResponseBehavior is what interactivity will do when handling something that isn't a valid valid button, in the context of waiting for a specific button. It defaults to @DSharpPlus.Interactivity.Enums.InteractionResponseBehavior.Ignore, which will cause the interaction fail. Alternatively, setting it to @DSharpPlus.Interactivity.Enums.InteractionResponseBehavior.Ack will acknowledge the button, and continue waiting. Respond will reply with an ephemeral message with the aforementioned response message. @DSharpPlus.Interactivity.InteractivityConfiguration.ResponseBehavior only applies to the overload accepting a string id of the button to wait for."
  },
  "articles/advanced_topics/generic_host.html": {
    "href": "articles/advanced_topics/generic_host.html",
    "title": "Generic Host | DSharpPlus",
    "keywords": "Introduction The .NET Generic Host is a reusable, lightweight, and extensible hosting framework that provides a consistent way to host different types of .NET applications. It is designed to simplify the startup process and provide a common infrastructure for configuring, logging, dependency injection, and other common tasks required by modern applications. It allows developers to build console applications, background services, and other types of .NET applications that can run as standalone processes, Windows services, or Docker containers, among other deployment options. By using a generic host, developers can focus on implementing the core business logic of their application rather than dealing with the infrastructure and plumbing required to host and manage it. You can read more about Generic hosts here. Making a Bot using the Generic Host Setting up the Builder To get started, you'll need to write some code that configures and runs your application. Here's a simple example that shows how to use the Generic Host to run a bot service: private static async Task Main() { await Host.CreateDefaultBuilder() .UseConsoleLifetime() .ConfigureServices((hostContext, services) => services.AddHostedService<BotService>()) .RunConsoleAsync(); } This code does a few things. First, it calls the Host.CreateDefaultBuilder() method, which creates a new IHostBuilder instance with some default settings. Then, it calls the UseConsoleLifetime() method to configure the lifetime of the host. This tells the host to keep running until it receives a SIGINT or SIGTERM Signal i.e. when the user presses Ctrl+C in the console, or when another program tells it to stop. Next, it configures the services that the host will use by calling the ConfigureServices() method. In this case, it adds a new BotService service, which is a class that you'll need to define next. Finally, it calls the RunConsoleAsync() method to start the host and begin running your service. That's it! With just a few lines of code, you can use the .NET Generic Host to run your application as a service. Setting up your Service You'll need to create a class which implements the IHostedService interface, which defines two methods: StartAsync() and StopAsync(). These methods are called by the host when your application starts and stops respectively. public sealed class BotService : IHostedService { private readonly ILogger<BotService> _logger; private readonly IHostApplicationLifetime _applicationLifetime; private readonly DiscordClient _discordClient; public BotService(ILogger<BotService> logger, IHostApplicationLifetime applicationLifetime) { this._logger = logger; this._applicationLifetime = applicationLifetime; this._discordClient = new(new() { Token = \"YourBotTokenHere\", TokenType = TokenType.Bot, Intents = DiscordIntents.AllUnprivileged }); } public async Task StartAsync(CancellationToken token) { await _discordClient.ConnectAsync(); // Other startup things here } public async Task StopAsync(CancellationToken token) { await _discordClient.DisconnectAsync(); // More cleanup possibly here } } Warning Hard-coding your bot token into your source code is not a good idea, especially if you plan to distribute your code publicly. This is because anyone with access to your code can easily extract your bot token, which can be used to perform unauthorized actions on your bot account. Instead, it's recommended that you store your bot token in a secure location, such as a configuration file, environment variable, or secret storage service. You can then retrieve the token at runtime and pass it to the initializer. See for example How to consume configuration with the Generic Host or how to use an environment variable. The StartAsync() method contains the code that runs when your application starts. In this case, the DiscordClient connects to the Discord API. The StopAsync() method contains the code that runs when your application is shut down. In the case of a bot, this might involve closing connections to external APIs, releasing resources, or performing other cleanup tasks. By implementing these methods, you can ensure that your application starts and stops cleanly, and that any necessary resources are properly managed. This makes it easier to build robust, reliable applications that can be run as services. With this class, you can easily create and run your own bot services using the .NET Generic Host. Just replace the Token property with your own Discord bot token, and you're ready to go! Using Serilog with the Generic Host Logging is an important part of any application, especially one that runs as a service. Fortunately, the .NET Generic Host makes it easy to integrate with popular logging libraries, like Serilog. Dependencies You will need the Serilog.Extensions.Hosting package (along with Serilog itself with whichever sinks you prefer), which are available from NuGet. In your Service Then, you will need to add Serilog to your DiscordClientConfiguration initializer block to ensure that your bot logs messages using Serilog. To do this, you will need to create a new LoggerFactory object and add the Serilog logger provider to it. You can also specify a minimum log level and silence certain DSharpPlus events, such as the \"unknown event\" log. this._discordClient = new(new() { [...] LoggerFactory = new LoggerFactory().AddSerilog(), MinimumLogLevel = LogLevel.Warning, LogUnknownEvents = false }); In your Host section When configuring the .NET Generic Host to use Serilog, you will need to add the logger service to your host builder and call the UseSerilog() method to configure Serilog as your logging provider. To do this, you can add the logger service to the ConfigureServices() method of your host builder, like this: await Host.CreateDefaultBuilder() .UseSerilog() .UseConsoleLifetime() .ConfigureServices((hostContext, services) => { services.AddLogging(logging => logging.ClearProviders().AddSerilog()); services.AddHostedService<BotService>(); }) .RunConsoleAsync(); In this example, we call the UseSerilog() method to configure Serilog as our logging provider, and then add the logger service to the ConfigureServices() method using the AddLogging() method on the Services collection. We then call the ClearProviders() method to remove any default logging providers that may be present, and add the Serilog provider using the AddSerilog() method. Don't forget that before you can use Serilog to log messages in your bot, you will need to initialize Serilog and configure the sinks you want to use. For example, you can initialize Serilog like this: Log.Logger = new LoggerConfiguration() .WriteTo.Console() .WriteTo.File(\"logs/.log\", rollingInterval: RollingInterval.Day) .CreateLogger(); When shutting down your bot, it's a good idea to call Log.CloseAndFlushAsync() to make sure that any pending log messages are written to the sinks before the process exits. You can add this call to your Main method, which could look like this once you're done: private static async Task Main() { Log.Logger = new LoggerConfiguration() .WriteTo.Console() .WriteTo.File(\"logs/.log\", rollingInterval: RollingInterval.Day) .CreateLogger(); await Host.CreateDefaultBuilder() .UseSerilog() .UseConsoleLifetime() .ConfigureServices((hostContext, services) => { services.AddLogging(logging => logging.ClearProviders().AddSerilog()); services.AddHostedService<BotService>(); }) .RunConsoleAsync(); await Log.CloseAndFlushAsync(); }"
  },
  "articles/advanced_topics/selects.html": {
    "href": "articles/advanced_topics/selects.html",
    "title": "Select Menus | DSharpPlus",
    "keywords": "Introduction They're here! What's here? Select menus (aka dropdowns) of course. Dropdowns are another message component added to the Discord API. Additionally, just like buttons, dropdowns are supported in all builders that take @DSharpPlus.Entities.DiscordComponent. However, dropdowns occupy an entire action row, so you can only have up to 5! Furthermore, buttons cannot occupy the same row as a dropdown. In this article, we will go over what dropdowns are, how to use them, and the limitations of dropdowns. Dropdowns overview Note This article is under the presumption that you are familiar with buttons. In addition to this, just like buttons, select menu ids should be unique. Dropdowns consist of several parts, and share some in common with buttons. They have a: Custom id Placeholder Disabled Options Min Values Max Values So lets go over these one by one, starting with the id. The id of a dropdown should of course be unique, just like buttons, and Discord will send this id back in the interaction object. Placeholder is also relatively relatively simple! It's hopefully self-explanatory, too. Placeholder text is the text the user will see when no options are selected. If you do not wish to have placeholder text, simply pass null as that parameter in the constructor for the dropdown. Placeholder only supports plain-text, and up to 100 characters. Disabled: Applies to the entire dropdown, and will grey it out if set to true. Min and Max values determine how many or how few options are valid. There are few requirements, though: Min < Max, Min >= 0, Max > 0, Max <= 25. Simple enough, right? \"But you skipped options!\", you may say, and that we have. Options are a bit more complicated, and have their own section right below. Dropdown options Dropdown options are somewhat more involved than handling buttons, but they're still relatively simple. They can have up to 25 options, but must have at least 1. These consist of several parts: Label Value Default Description Emoji Label is the label of the option. This is always required, and can be up to 100 characters long. Value is like the custom id of the dropdown; for the most part it should be unique. This will be accessible on the @DSharpPlus.Entities.DiscordInteractionData.Values property the interaction, and will contain all the selected options. Individual values unfortunately cannot be disabled. Description is text that is placed under the label on each option, and can also be up to 100 characters. This text is also plain-text, and does not support markdown. Default determines whether or not the option will be the default option (which overrides placeholder). If you set multiple to default (and allow multiple to be selected), the user will see the options as pre-selected. Emoji is the same as a button. You can pass an emoji id, a unicode emote or a DiscordEmoji object, which will automatically use either. Warning When using DiscordComponentEmoji's string overload, you MUST use the unicode representation of the emoji you want. ex: 👋 and not :wave: Putting it all together Note Spaces are valid in custom ids as well, but underscores will be used in this article for consistency. Well now you know how dropdowns work, and how dropdown options work, but how do you make the darn thing??? It would look something along the lines of this: // Create the options for the user to pick var options = new List<DiscordSelectComponentOption>() { new DiscordSelectComponentOption( \"Label, no description\", \"label_no_desc\"), new DiscordSelectComponentOption( \"Label, Description\", \"label_with_desc\", \"This is a description!\"), new DiscordSelectComponentOption( \"Label, Description, Emoji\", \"label_with_desc_emoji\", \"This is a description!\", emoji: new DiscordComponentEmoji(854260064906117121)), new DiscordSelectComponentOption( \"Label, Description, Emoji (Default)\", \"label_with_desc_emoji_default\", \"This is a description!\", isDefault: true, new DiscordComponentEmoji(854260064906117121)) }; // Make the dropdown var dropdown = new DiscordSelectComponent(\"dropdown\", null, options, false, 1, 2); Okay, so we have a dropdown...now what? Simply pass it to any builder that constructs a response, be it a @DSharpPlus.Entities.DiscordMessageBuilder, @DSharpPlus.Entities.DiscordInteractionResponseBuilder, or @DSharpPlus.Entities.DiscordWebhookBuilder. It'll look something like this, using the code above: // [...] Code trunctated for brevity var builder = new DiscordMessageBuilder() .WithContent(\"Look, it's a dropdown!\") .AddComponents(dropdown); await builder.SendAsync(channel); // Replace with any method of getting a channel. // Final result Congrats! You've made a dropdown. It should look like this When you click the dropdown, the bottom option should be pre-selected, and it will look like this. You can choose one or two options. Interactivity/Footnotes \"Oh no, I'm getting 'This interaction failed' when selecting! What do I do?\" Dropdowns are like buttons; when a user interacts with them, you need to respond to that interaction. @DSharpPlus.DiscordClient.ComponentInteractionCreated is fired from the client, just like buttons. This applies to interactivity, too! Simply swap @DSharpPlus.Interactivity.Extensions.MessageExtensions.WaitForButtonAsync*for @DSharpPlus.Interactivity.Extensions.MessageExtensions.WaitForSelectAsync*, and pass a dropdown. How to go about component-based interactivity is described in the buttons article. And that's it! Go forth and create amazing things."
  },
  "articles/audio/lavalink/configuration.html": {
    "href": "articles/audio/lavalink/configuration.html",
    "title": "Lavalink Configuration | DSharpPlus",
    "keywords": "Setting up DSharpPlus.Lavalink Configuring Your Client To begin using DSharpPlus's Lavalink client, you will need to add the DSharpPlus.Lavalink nuget package. Once installed, simply add these namespaces at the top of your bot file: using DSharpPlus.Net; using DSharpPlus.Lavalink; After that, we will need to create a configuration for our extension to use. This is where the special values from the server configuration are used. var endpoint = new ConnectionEndpoint { Hostname = \"127.0.0.1\", // From your server configuration. Port = 2333 // From your server configuration }; var lavalinkConfig = new LavalinkConfiguration { Password = \"youshallnotpass\", // From your server configuration. RestEndpoint = endpoint, SocketEndpoint = endpoint }; Finally, initialize the extension. var lavalink = Discord.UseLavalink(); Connecting with Lavalink We are now ready to connect to the server. Call the Lavalink extension's connect method and pass the configuration. Make sure to call this after your Discord client connects. This can be called either directly after your client's connect method or in your client's ready event. LavalinkNode = await Lavalink.ConnectAsync(lavalinkConfig); Your main bot file should now look like this: using System.Threading.Tasks; using Microsoft.Extensions.Logging; using DSharpPlus; using DSharpPlus.Net; using DSharpPlus.Lavalink; namespace MyFirstMusicBot { class Program { public static DiscordClient Discord; static void Main(string[] args) { MainAsync(args).ConfigureAwait(false).GetAwaiter().GetResult(); } static async Task MainAsync(string[] args) { Discord = new DiscordClient(new DiscordConfiguration { Token = \"<token_here>\", TokenType = TokenType.Bot, MinimumLogLevel = LogLevel.Debug }); var endpoint = new ConnectionEndpoint { Hostname = \"127.0.0.1\", // From your server configuration. Port = 2333 // From your server configuration }; var lavalinkConfig = new LavalinkConfiguration { Password = \"youshallnotpass\", // From your server configuration. RestEndpoint = endpoint, SocketEndpoint = endpoint }; var lavalink = Discord.UseLavalink(); await Discord.ConnectAsync(); await lavalink.ConnectAsync(lavalinkConfig); // Make sure this is after Discord.ConnectAsync(). await Task.Delay(-1); } } } We are now ready to start the bot. If everything is configured properly, you should see a Lavalink connection appear in your DSharpPlus console: [2020-10-10 17:56:07 -04:00] [403 /LavalinkConn] [Debug] Connection to Lavalink node established And a client connection appear in your Lavalink console: INFO 5180 --- [ XNIO-1 task-1] io.undertow.servlet : Initializing Spring DispatcherServlet 'dispatcherServlet' INFO 5180 --- [ XNIO-1 task-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet' INFO 5180 --- [ XNIO-1 task-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 8 ms INFO 5180 --- [ XNIO-1 task-1] l.server.io.HandshakeInterceptorImpl : Incoming connection from /0:0:0:0:0:0:0:1:58238 INFO 5180 --- [ XNIO-1 task-1] lavalink.server.io.SocketServer : Connection successfully established from /0:0:0:0:0:0:0:1:58238 We are now ready to set up some music commands!"
  },
  "articles/audio/lavalink/music_commands.html": {
    "href": "articles/audio/lavalink/music_commands.html",
    "title": "Lavalink Music Commands | DSharpPlus",
    "keywords": "Adding Music Commands This article assumes that you know how to use CommandsNext. If you do not, you should learn here before continuing with this guide. Prerequisites Before we start we will need to make sure CommandsNext is configured. For this we can make a simple configuration and command class: using DSharpPlus.CommandsNext; namespace MyFirstMusicBot { public class MyLavalinkCommands : BaseCommandModule { } } And be sure to register it in your program file: CommandsNext = Discord.UseCommandsNext(new CommandsNextConfiguration { StringPrefixes = new string[] { \";;\" } }); CommandsNext.RegisterCommands<MyLavalinkCommands>(); Adding join and leave commands Your bot, and Lavalink, will need to connect to a voice channel to play music. Let's create the base for these commands: [Command] public async Task Join(CommandContext ctx, DiscordChannel channel) { } [Command] public async Task Leave(CommandContext ctx, DiscordChannel channel) { } In order to connect to a voice channel, we'll need to do a few things. Get our node connection. You can either use linq or @DSharpPlus.Lavalink.LavalinkExtension.GetIdealNodeConnection* Check if the channel is a voice channel, and tell the user if not. Connect the node to the channel. And for the leave command: Get the node connection, using the same process. Check if the channel is a voice channel, and tell the user if not. Get our existing connection. Check if the connection exists, and tell the user if not. Disconnect from the channel. @DSharpPlus.Lavalink.LavalinkExtension.GetIdealNodeConnection* will return the least affected node through load balancing, which is useful for larger bots. It can also filter nodes based on an optional voice region to use the closest nodes available. Since we only have one connection we can use linq's .First() method on the extensions connected nodes to get what we need. So far, your command class should look something like this: using System.Threading.Tasks; using DSharpPlus; using DSharpPlus.Entities; using DSharpPlus.CommandsNext; using DSharpPlus.CommandsNext.Attributes; namespace MyFirstMusicBot { public class MyLavalinkCommands : BaseCommandModule { [Command] public async Task Join(CommandContext ctx, DiscordChannel channel) { var lava = ctx.Client.GetLavalink(); if (!lava.ConnectedNodes.Any()) { await ctx.RespondAsync(\"The Lavalink connection is not established\"); return; } var node = lava.ConnectedNodes.Values.First(); if (channel.Type != ChannelType.Voice) { await ctx.RespondAsync(\"Not a valid voice channel.\"); return; } await node.ConnectAsync(channel); await ctx.RespondAsync($\"Joined {channel.Name}!\"); } [Command] public async Task Leave(CommandContext ctx, DiscordChannel channel) { var lava = ctx.Client.GetLavalink(); if (!lava.ConnectedNodes.Any()) { await ctx.RespondAsync(\"The Lavalink connection is not established\"); return; } var node = lava.ConnectedNodes.Values.First(); if (channel.Type != ChannelType.Voice) { await ctx.RespondAsync(\"Not a valid voice channel.\"); return; } var conn = node.GetGuildConnection(channel.Guild); if (conn == null) { await ctx.RespondAsync(\"Lavalink is not connected.\"); return; } await conn.DisconnectAsync(); await ctx.RespondAsync($\"Left {channel.Name}!\"); } } } Adding player commands Now that we can join a voice channel, we can make our bot play music! Let's now create the base for a play command: [Command] public async Task Play(CommandContext ctx, [RemainingText] string search) { } One of Lavalink's best features is its ability to search for tracks from a variety of media sources, such as YouTube, SoundCloud, Twitch, and more. This is what makes bots like Rythm, Fredboat, and Groovy popular. The search is used in a REST request to get the track data, which is then sent through the WebSocket connection to play the track in the voice channel. That is what we will be doing in this command. Lavalink can also play tracks directly from a media url, in which case the play command can look like this: [Command] public async Task Play(CommandContext ctx, Uri url) { } Like before, we will need to get our node and guild connection and have the appropriate checks. Since it wouldn't make sense to have the channel as a parameter, we will instead get it from the member's voice state: //Important to check the voice state itself first, //as it may throw a NullReferenceException if they don't have a voice state. if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null) { await ctx.RespondAsync(\"You are not in a voice channel.\"); return; } var lava = ctx.Client.GetLavalink(); var node = lava.ConnectedNodes.Values.First(); var conn = node.GetGuildConnection(ctx.Member.VoiceState.Guild); if (conn == null) { await ctx.RespondAsync(\"Lavalink is not connected.\"); return; } Next, we will get the track details by calling @DSharpPlus.Lavalink.LavalinkGuildConnection.GetTracksAsync*. There is a variety of overloads for this: @DSharpPlus.Lavalink.LavalinkGuildConnection.GetTracksAsync(System.String,DSharpPlus.Lavalink.LavalinkSearchType) will search various services for the specified query: @DSharpPlus.Lavalink.LavalinkSearchType.Youtube will search YouTube @DSharpPlus.Lavalink.LavalinkSearchType.SoundCloud will search SoundCloud @DSharpPlus.Lavalink.LavalinkGuildConnection.GetTracksAsync(Uri) will use the direct url to obtain the track. This is mainly used for the other media sources. For this guide we will be searching YouTube. Let's pass in our search string and store the result in a variable: //We don't need to specify the search type here //since it is YouTube by default. var loadResult = await node.Rest.GetTracksAsync(search); The load result will contain an enum called @DSharpPlus.Lavalink.LavalinkLoadResult.LoadResultType, which will inform us if Lavalink was able to retrieve the track data. We can use this as a check: //If something went wrong on Lavalink's end if (loadResult.LoadResultType == LavalinkLoadResultType.LoadFailed //or it just couldn't find anything. || loadResult.LoadResultType == LavalinkLoadResultType.NoMatches) { await ctx.RespondAsync($\"Track search failed for {search}.\"); return; } Lavalink will return the track data from your search in a collection called @DSharpPlus.Lavalink.LavalinkLoadResult.Tracks, similar to using the search bar in YouTube or SoundCloud directly. The first track is typically the most accurate one, so that is what we will use: var track = loadResult.Tracks.First(); And finally, we can play the track: await conn.PlayAsync(track); await ctx.RespondAsync($\"Now playing {track.Title}!\"); Your play command should look like this: [Command] public async Task Play(CommandContext ctx, [RemainingText] string search) { if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null) { await ctx.RespondAsync(\"You are not in a voice channel.\"); return; } var lava = ctx.Client.GetLavalink(); var node = lava.ConnectedNodes.Values.First(); var conn = node.GetGuildConnection(ctx.Member.VoiceState.Guild); if (conn == null) { await ctx.RespondAsync(\"Lavalink is not connected.\"); return; } var loadResult = await node.Rest.GetTracksAsync(search); if (loadResult.LoadResultType == LavalinkLoadResultType.LoadFailed || loadResult.LoadResultType == LavalinkLoadResultType.NoMatches) { await ctx.RespondAsync($\"Track search failed for {search}.\"); return; } var track = loadResult.Tracks.First(); await conn.PlayAsync(track); await ctx.RespondAsync($\"Now playing {track.Title}!\"); } Being able to pause the player is also useful. For this we can use most of the base from the play command: [Command] public async Task Pause(CommandContext ctx) { if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null) { await ctx.RespondAsync(\"You are not in a voice channel.\"); return; } var lava = ctx.Client.GetLavalink(); var node = lava.ConnectedNodes.Values.First(); var conn = node.GetGuildConnection(ctx.Member.VoiceState.Guild); if (conn == null) { await ctx.RespondAsync(\"Lavalink is not connected.\"); return; } } For this command we will also want to check the player state to determine if we should send a pause command. We can do so by checking @DSharpPlus.Lavalink.Entities.LavalinkPlayerState.CurrentTrack: if (conn.CurrentState.CurrentTrack == null) { await ctx.RespondAsync(\"There are no tracks loaded.\"); return; } And finally, we can call pause: await conn.PauseAsync(); The finished command should look like so: [Command] public async Task Pause(CommandContext ctx) { if (ctx.Member.VoiceState == null || ctx.Member.VoiceState.Channel == null) { await ctx.RespondAsync(\"You are not in a voice channel.\"); return; } var lava = ctx.Client.GetLavalink(); var node = lava.ConnectedNodes.Values.First(); var conn = node.GetGuildConnection(ctx.Member.VoiceState.Guild); if (conn == null) { await ctx.RespondAsync(\"Lavalink is not connected.\"); return; } if (conn.CurrentState.CurrentTrack == null) { await ctx.RespondAsync(\"There are no tracks loaded.\"); return; } await conn.PauseAsync(); } Of course, there are other commands Lavalink has to offer. Check out the docs to view the commands you can use while playing tracks. There are also open source examples such as Emzi0767's Companion Cube Bot and Turret Bot."
  },
  "articles/audio/lavalink/setup.html": {
    "href": "articles/audio/lavalink/setup.html",
    "title": "Lavalink Setup | DSharpPlus",
    "keywords": "Lavalink - the newer, better way to do music Lavalink is a standalone program, written in Java. It's a lightweight solution for playing music from sources such as YouTube or Soundcloud. Unlike raw voice solutions, such as VoiceNext, Lavalink can handle hundreds of concurrent streams, and supports sharding. Configuring Java In order to run Lavalink, you must have Java 13 or greater installed. Certain Java versions may not be functional with Lavalink, so it is best to check the requirements before downloading. The latest releases can be found here. Make sure the location of the newest JRE's bin folder is added to your system variable's path. This will make the java command run from the latest runtime. You can verify that you have the right version by entering java -version in your command prompt or terminal. Downloading Lavalink Next, head over to the releases tab on the Lavalink GitHub page and download the Jar file from the latest version. Alternatively, stable builds with the latest changes can be found on their CI Server. The program will not be ready to run yet, as you will need to create a configuration file first. To do so, create a new YAML file called application.yml, and use the example file, or copy this text: server: # REST and WS server port: 2333 address: 127.0.0.1 spring: main: banner-mode: log lavalink: server: password: \"youshallnotpass\" sources: youtube: true bandcamp: true soundcloud: true twitch: true vimeo: true mixer: true http: true local: false bufferDurationMs: 400 youtubePlaylistLoadLimit: 6 # Number of pages at 100 each youtubeSearchEnabled: true soundcloudSearchEnabled: true gc-warnings: true metrics: prometheus: enabled: false endpoint: /metrics sentry: dsn: \"\" # tags: # some_key: some_value # another_key: another_value logging: file: max-history: 30 max-size: 1GB path: ./logs/ level: root: INFO lavalink: INFO YAML is whitespace-sensitive. Make sure you are using a text editor which properly handles this. There are a few values to keep in mind. host is the IP of the Lavalink host. This will be 0.0.0.0 by default, but it should be changed as it is a security risk. For this guide, set this to 127.0.0.1 as we will be running Lavalink locally. port is the allowed port for the Lavalink connection. 2333 is the default port, and is what will be used for this guide. password is the password that you will need to specify when connecting. This can be anything as long as it is a valid YAML string. Keep it as youshallnotpass for this guide. When you are finished configuring this, save the file in the same directory as your Lavalink executable. Keep note of your port, address, and password values, as you will need them later for connecting. Starting Lavalink Open your command prompt or terminal and navigate to the directory containing Lavalink. Once there, type java -jar Lavalink.jar. You should start seeing log output from Lavalink. If everything is configured properly, you should see this appear somewhere in the log output without any errors: [ main] lavalink.server.Launcher : Started Launcher in 5.769 seconds (JVM running for 6.758) If it does, congratulations. We are now ready to interact with it using DSharpPlus."
  },
  "articles/audio/voicenext/prerequisites.html": {
    "href": "articles/audio/voicenext/prerequisites.html",
    "title": "VoiceNext Prerequisites | DSharpPlus",
    "keywords": "Required Libraries VoiceNext depends on the libsodium and Opus libraries to decrypt and process audio packets. Both must be available on your development and host machines otherwise VoiceNext will not work. Windows When installing VoiceNext though NuGet, an additional package containing the native Windows binaries will automatically be included with no additional steps required. However, if you are using DSharpPlus from source or without a NuGet package manager, you must manually download the binaries and place them at the root of your working directory where your application is located. MacOS Native libraries for Apple's macOS can be installed using the Homebrew package manager: brew install opus libsodium Linux Debian and Derivatives Opus package naming is consistent across Debian, Ubuntu, and most derivatives. sudo apt-get install libopus0 libopus-dev Package naming for libsodium will vary depending on your distro and version: Distributions Terminal Command Ubuntu 20.04, Ubuntu 18.04, Debian 10, Debian 11 sudo apt-get install libsodium23 libsodium-dev Linux Mint, Ubuntu 16.04, Debian 9 sudo apt-get install libsodium18 libsodium-dev"
  },
  "articles/audio/voicenext/receive.html": {
    "href": "articles/audio/voicenext/receive.html",
    "title": "Receiving | DSharpPlus",
    "keywords": "Receiving with VoiceNext Enable Receiver Receiving incoming audio is disabled by default to save on bandwidth, as most users will never make use of incoming data. This can be changed by providing a configuration object to @DSharpPlus.VoiceNext.DiscordClientExtensions.UseVoiceNext*. var discord = new DiscordClient(); discord.UseVoiceNext(new VoiceNextConfiguration() { EnableIncoming = true }); Establish Connection The voice channel join process is the exact same as when transmitting. DiscordChannel channel; VoiceNextConnection connection = await channel.ConnectAsync(); Write Event Handler We'll be able to receive incoming audio from the @DSharpPlus.VoiceNext.VoiceNextConnection.VoiceReceived event fired by @DSharpPlus.VoiceNext.VoiceNextConnection. connection.VoiceReceived += ReceiveHandler; Writing the logic for this event handler will depend on your overall goal. The event arguments will contain a PCM audio packet for you to make use of. You can convert each packet to another format, concatenate them all together, feed them into an external program, or process the packets any way that'll suit your needs. When a user is speaking, @DSharpPlus.VoiceNext.VoiceNextConnection.VoiceReceived should fire once every twenty milliseconds and its packet will contain around twenty milliseconds worth of audio; this can vary due to differences in client settings. To help keep track of the torrent of packets for each user, you can use user IDs in combination the synchronization value (SSRC) sent by Discord to determine the source of each packet. This short-and-simple example will use ffmpeg to convert each packet to a wav file. private async Task ReceiveHandler(VoiceNextConnection _, VoiceReceiveEventArgs args) { var name = DateTimeOffset.Now.ToUnixTimeMilliseconds(); var ffmpeg = Process.Start(new ProcessStartInfo { FileName = \"ffmpeg\", Arguments = $@\"-ac 2 -f s16le -ar 48000 -i pipe:0 -ac 2 -ar 44100 {name}.wav\", RedirectStandardInput = true }); await ffmpeg.StandardInput.BaseStream.WriteAsync(args.PcmData); } That's really all there is to it. Connect to a voice channel, hook an event, process the data as you see fit. Example Commands [Command(\"start\")] public async Task StartCommand(CommandContext ctx, DiscordChannel channel = null) { channel ??= ctx.Member.VoiceState?.Channel; var connection = await channel.ConnectAsync(); Directory.CreateDirectory(\"Output\"); connection.VoiceReceived += VoiceReceiveHandler; } [Command(\"stop\")] public Task StopCommand(CommandContext ctx) { var vnext = ctx.Client.GetVoiceNext(); var connection = vnext.GetConnection(ctx.Guild); connection.VoiceReceived -= VoiceReceiveHandler; connection.Dispose(); return Task.CompletedTask; } private async Task VoiceReceiveHandler(VoiceNextConnection connection, VoiceReceiveEventArgs args) { var fileName = DateTimeOffset.Now.ToUnixTimeMilliseconds(); var ffmpeg = Process.Start(new ProcessStartInfo { FileName = \"ffmpeg\", Arguments = $@\"-ac 2 -f s16le -ar 48000 -i pipe:0 -ac 2 -ar 44100 Output/{fileName}.wav\", RedirectStandardInput = true }); await ffmpeg.StandardInput.BaseStream.WriteAsync(args.PcmData); ffmpeg.Dispose(); }"
  },
  "articles/audio/voicenext/transmit.html": {
    "href": "articles/audio/voicenext/transmit.html",
    "title": "Transmitting | DSharpPlus",
    "keywords": "Transmitting with VoiceNext Enable VoiceNext Install the DSharpPlus.VoiceNext package from NuGet. Then use the @DSharpPlus.VoiceNext.DiscordClientExtensions.UseVoiceNext* extension method on your instance of @DSharpPlus.DiscordClient. var discord = new DiscordClient(); discord.UseVoiceNext(); Connect Joining a voice channel is very easy; simply use the @DSharpPlus.VoiceNext.DiscordClientExtensions.ConnectAsync* extension method on @DSharpPlus.Entities.DiscordChannel. DiscordChannel channel; VoiceNextConnection connection = await channel.ConnectAsync(); Transmit Discord requires that we send Opus encoded stereo PCM audio data at a sample rate of 48kHz. You'll need to convert your audio source to PCM S16LE using your preferred program for media conversion, then read that data into a Stream object or an array of byte to be used with VoiceNext. Opus encoding of the PCM data will be done automatically by VoiceNext before sending it to Discord. This example will use ffmpeg to convert an MP3 file to a PCM stream. var filePath = \"funiculi_funicula.mp3\"; var ffmpeg = Process.Start(new ProcessStartInfo { FileName = \"ffmpeg\", Arguments = $@\"-i \"\"{filePath}\"\" -ac 2 -f s16le -ar 48000 pipe:1\", RedirectStandardOutput = true, UseShellExecute = false }); Stream pcm = ffmpeg.StandardOutput.BaseStream; Now that our audio is the correct format, we'll need to get a transmit sink for the channel we're connected to. You can think of the transmit stream as our direct interface with a voice channel; any data written to one will be processed by VoiceNext, queued, and sent to Discord which will then be output to the connected voice channel. VoiceTransmitSink transmit = connection.GetTransmitSink(); Once we have a transmit sink, we can 'play' our audio by copying our PCM data to the transmit sink buffer. await pcm.CopyToAsync(transmit); Stream#CopyToAsync() will copy PCM data from the input stream to the output sink, up to the sink's configured capacity, at which point it will wait until it can copy more. This means that the call will hold the task's execution, until such time that the entire input stream has been consumed, and enqueued in the sink. This operation cannot be cancelled. If you'd like to have finer control of the playback, you should instead consider using Stream#ReadAsync() and VoiceTransmitSink#WriteAsync() to manually copy small portions of PCM data to the transmit sink. Disconnect Similar to joining, leaving a voice channel is rather straightforward. var vnext = discord.GetVoiceNext(); var connection = vnext.GetConnection(); connection.Disconnect(); Example Commands [Command(\"join\")] public async Task JoinCommand(CommandContext ctx, DiscordChannel channel = null) { channel ??= ctx.Member.VoiceState?.Channel; await channel.ConnectAsync(); } [Command(\"play\")] public async Task PlayCommand(CommandContext ctx, string path) { var vnext = ctx.Client.GetVoiceNext(); var connection = vnext.GetConnection(ctx.Guild); var transmit = connection.GetTransmitSink(); var pcm = ConvertAudioToPcm(path); await pcm.CopyToAsync(transmit); await pcm.DisposeAsync(); } [Command(\"leave\")] public async Task LeaveCommand(CommandContext ctx) { var vnext = ctx.Client.GetVoiceNext(); var connection = vnext.GetConnection(ctx.Guild); connection.Disconnect(); } private Stream ConvertAudioToPcm(string filePath) { var ffmpeg = Process.Start(new ProcessStartInfo { FileName = \"ffmpeg\", Arguments = $@\"-i \"\"{filePath}\"\" -ac 2 -f s16le -ar 48000 pipe:1\", RedirectStandardOutput = true, UseShellExecute = false }); return ffmpeg.StandardOutput.BaseStream; }"
  },
  "articles/basics/bot_account.html": {
    "href": "articles/basics/bot_account.html",
    "title": "Creating a Bot Account | DSharpPlus",
    "keywords": "Creating a Bot Account Create an Application Before you're able to create a bot account to interact with the Discord API, you'll need to create a new OAuth2 application. Go to the Discord Developer Portal and click New Application at the top right of the page. You'll then be prompted to enter a name for your application. The name of your application will be the name displayed to users when they add your bot to their Discord server. With that in mind, it would be a good idea for your application name to match the desired name of your bot. Enter your desired application name into the text box, then hit the Create button. After you hit Create, you'll be taken to the application page for your newly created application. That was easy, wasn't it? Before you move on, you may want to upload an icon for your application and provide a short description of what your bot will do. As with the name of your application, the application icon and description will be displayed to users when adding your bot. Add a Bot Account Now that you have an application created, you'll be able to add a brand new bot account to it. Head on over to the bot page of your application by clicking on Bot in the left panel. From there, click on the Add Bot button at the top right of the page. Then confirm the creation of the bot account. Using Your Bot Account Invite Your Bot Now that you have a bot account, you'll probably want to invite it to a server! A bot account joins a server through a special invite link that'll take users through the OAuth2 flow; you'll probably be familiar with this if you've ever added a public Discord bot to a server. To get the invite link for your bot, head on over to the OAuth2 page of your application. We'll be using the *OAuth2 URL Generator* on this page. Simply tick `bot` under the *scopes* panel; your bot invite link will be generated directly below. By default, the generated link will not grant any permissions to your bot when it joins a new server. If your bot requires specific permissions to function, you'd select them in the *bot permissions* panel. The invite link in the scopes panel will update each time you change the permissions. Be sure to copy it again after any changes! Get Bot Token Instead of logging in to Discord with a username and password, bot accounts use a long string called a token to authenticate. You'll want to retrieve the token for your bot account so you can use it with DSharpPlus. Head back to the bot page and click on Click to Reveal Token just above the Copy and Regenerate buttons to take a peek at your token. Go ahead and copy your bot token and save it somewhere. You'll be using it soon! Important Handle your bot token with care! Anyone who has your token will have access to your bot account. Be sure to store it in a secure location and never give it to anybody. If you ever believe your token has been compromised, be sure to hit the Regenerate button (as seen above) to invalidate your old token and get a brand new token. Write Some Code You've got a bot account set up and a token ready for use. Sounds like it's time for you to write your first bot!"
  },
  "articles/basics/first_bot.html": {
    "href": "articles/basics/first_bot.html",
    "title": "Your First Bot | DSharpPlus",
    "keywords": "Your First Bot Note This article assumes the following: You have created a bot account and have a bot token. You have Visual Studio installed on your computer. Create a Project Open up Visual Studio and click on Create a new project towards the bottom right. Select Console App then click on the Next button. Next, you'll give your project a name. For this example, we'll name it MyFirstBot. If you'd like, you can also change the directory that your project will be created in. Enter your desired project name, then click on the Create button. Voilà! Your project has been created! Install Package Now that you have a project created, you'll want to get DSharpPlus installed. Locate the solution explorer on the right side, then right click on Dependencies and select Manage NuGet Packages from the context menu. You'll then be greeted by the NuGet package manager. Select the Browse tab towards the top left, then type DSharpPlus into the search text box. The first results should be the six DSharpPlus packages. Package Description DSharpPlus Main package; Discord API client. DSharpPlus.CommandsNext Add-on which provides a command framework. DSharpPlus.SlashCommands Add-on which provides an application command framework. DSharpPlus.Interactivity Add-on which allows for interactive commands. DSharpPlus.Lavalink Client implementation for Lavalink. Useful for music bots. DSharpPlus.VoiceNext Add-on which enables connectivity to Discord voice channels. DSharpPlus.Rest REST-only Discord client. We'll only need the DSharpPlus package for the basic bot we'll be writing in this article. Select it from the list then click the Install button to the right (after verifing that you will be installing the latest version). You're now ready to write some code! First Lines of Code DSharpPlus implements the Task-based Asynchronous Pattern. Because of this, the majority of DSharpPlus methods must be executed in a method marked as async so they can be properly awaited. We will therefore proceed to mark our Main method as async, which also means it has to return Task instead of void. Head back to your Program.cs tab and edit the method as discussed. static async Task Main(string[] args) { } If you typed this in by hand, Intellisense should have generated the required using directive for you. However, if you copy-pasted the snippet above, VS will complain about being unable to find the Task type. Hover over Task with your mouse and click on Show potential fixes from the tooltip. Then apply the recommended solution. We'll now create a new DiscordClient instance in our brand new asynchronous method. Create a new variable in Main and assign it a new @DSharpPlus.DiscordClient instance, then pass an instance of @DSharpPlus.DiscordConfiguration to its constructor. Create an object initializer for @DSharpPlus.DiscordConfiguration and populate the @DSharpPlus.DiscordConfiguration.Token property with your bot token then set the @DSharpPlus.DiscordConfiguration.TokenType property to @DSharpPlus.TokenType.Bot. Next add the @DSharpPlus.DiscordClient.Intents property and populate it with @DSharpPlus.DiscordIntents.AllUnprivileged. These Intents are required for certain events to be fired. Please visit this article for more information. var discord = new DiscordClient(new DiscordConfiguration() { Token = \"My First Token\", TokenType = TokenType.Bot, Intents = DiscordIntents.AllUnprivileged }); Warning We hard-code the token in the above snippet to keep things simple and easy to understand. Hard-coding your token is not a smart idea, especially if you plan on distributing your source code. Instead you should store your token in an external medium, such as a configuration file or environment variable, and read that into your program to be used with DSharpPlus. Follow that up with @DSharpPlus.DiscordClient.ConnectAsync* to connect and login to Discord, and await Task.Delay(-1); at the end of the method to prevent the console window from closing prematurely. var discord = new DiscordClient(); await discord.ConnectAsync(); await Task.Delay(-1); As before, Intellisense will have auto generated the needed using directive for you if you typed this in by hand. If you've copied the snippet, be sure to apply the recommended suggestion to insert the required directive. If you hit F5 on your keyboard to compile and run your program, you'll be greeted by a happy little console with a single log message from DSharpPlus. Woo hoo! Spicing Up Your Bot Right now our bot doesn't do a whole lot. Let's bring it to life by having it respond to a message! As of September 1st 2022, Discord started requiring message content intent for bots that want to read message content. This is a privileged intent! If your bot has under 100 guilds, all you have to do is flip the switch in the developer dashboard. (over at https://discord.com/developers/applications) If your bot has over 100 guilds, you'll need approval from Discord's end. After enabling the intent in the developer dashboard, you have to specify your intents in you DiscordConfiguration: var discord = new DiscordClient(new DiscordConfiguration() { Token = \"My First Token\", TokenType = TokenType.Bot, Intents = DiscordIntents.AllUnprivileged | DiscordIntents.MessageContents }); Now you can start to listen to messages. Hook the @DSharpPlus.DiscordClient.MessageCreated event fired by @DSharpPlus.DiscordClient with a lambda. Mark it as async and give it two parameters: s and e. discord.MessageCreated += async (s, e) => { }; Then, add an if statement into the body of your event lambda that will check if @DSharpPlus.Entities.DiscordMessage.Content starts with your desired trigger word and respond with a message using @DSharpPlus.Entities.DiscordMessage.RespondAsync*if it does. For this example, we'll have the bot to respond with pong!for each message that starts withping. discord.MessageCreated += async (s, e) => { if (e.Message.Content.ToLower().StartsWith(\"ping\")) await e.Message.RespondAsync(\"pong!\"); }; The Finished Product Your entire program should now look like this: using System; using System.Threading.Tasks; using DSharpPlus; namespace MyFirstBot { class Program { static async Task Main(string[] args) { var discord = new DiscordClient(new DiscordConfiguration() { Token = \"My First Token\", TokenType = TokenType.Bot, Intents = DiscordIntents.AllUnprivileged | DiscordIntents.MessageContents }); discord.MessageCreated += async (s, e) => { if (e.Message.Content.ToLower().StartsWith(\"ping\")) await e.Message.RespondAsync(\"pong!\"); }; await discord.ConnectAsync(); await Task.Delay(-1); } } } Hit F5 to run your bot, then send ping in any channel your bot account has access to. Your bot should respond with pong! for each ping you send. Congrats, your bot now does something! Further Reading Now that you have a basic bot up and running, you should take a look at the following: Events CommandsNext"
  },
  "articles/beyond_basics/events.html": {
    "href": "articles/beyond_basics/events.html",
    "title": "DSharpPlus Events | DSharpPlus",
    "keywords": "Consuming Events DSharpPlus makes use of asynchronous events which will execute each handler asynchronously and in parallel. This event system will require event handlers have a Task return type and take two parameters. The first parameter will contain an instance of the object which fired the event. The second parameter will contain an arguments object for the specific event you're handling. Below is a snippet demonstrating this with a lambda expression. private async Task Main(string[] args) { var discord = new DiscordClient(); discord.MessageCreated += async (s, e) => { if (e.Message.Content.ToLower().Contains(\"spiderman\")) await e.Message.RespondAsync(\"I want pictures of Spiderman!\"); }; discord.GuildMemberAdded += (s, e) => { // Non asynchronous code here. return Task.CompletedTask; }; } Alternatively, you can create a new method to consume an event. private async Task Main(string[] args) { var discord = new DiscordClient(); discord.MessageCreated += MessageCreatedHandler; discord.GuildMemberAdded += MemberAddedHandler; } private async Task MessageCreatedHandler(DiscordClient s, MessageCreateEventArgs e) { if (e.Guild?.Id == 379378609942560770 && e.Author.Id == 168548441939509248) await e.Message.DeleteAsync(); } private Task MemberAddedHandler(DiscordClient s, GuildMemberAddEventArgs e) { // Non asynchronous code here. return Task.CompletedTask; } You should only register or unregister events on startup or on deterministic points in execution: do not change event handlers based on user input, in commands or anything related unless you have a very good reason. Usage of the right events We advise against the use of the Ready event in the DiscordClient, as it does not necessarily mean that the client is ready. If the goal is to obtain DiscordMember/DiscordGuild information, this event should not be used. Instead, the GuildDownloadCompleted event should be used. The Ready event is only meant to signal that the client has finished the initial handshake with the gateway and is prepared to begin sending payloads. Migrating to parallel events In D#+ v4.4.0, events were changed from executing sequentially (each event runs its registered handlers one by one) to executing in parallel (each event throws all its handlers onto the thread pool). This change has a few benefits, from mitigating deadlocks previously occurring with certain interactivity-commandsnext interactions to allowing EventArgs objets to be garbage collected sooner. For end users, this change should not cause any problems, unless: IF you previously had an event handler for ComponentInteractionCreated that indiscriminately responded to all interactions while also using button interactivity, your code will break. Make sure you only respond to events you actually handle. IF you previously had two different event handlers on the same event relying on one completing before the other, your code will break. Either register only one event handler dealing with all your logic, or manage state yourself. This change also means that there is no longer a timeout on event handlers, and your event handler is free to take however long it needs to. There is no longer a reason to wrap your events in a _ = Task.Run(async () => // logic);."
  },
  "articles/beyond_basics/intents.html": {
    "href": "articles/beyond_basics/intents.html",
    "title": "Intents | DSharpPlus",
    "keywords": "Intents Intents were added to Discord to help the service not have to push so many events to the bots that were not using them. If you are going to be needing to subscribe to any type of event, they are going to have to be defined BOTH within the Discord Application under the Bot Page on Discords Site and also within the @DSharpPlus.DiscordConfiguration. Discord Application On the Discord Application under the Bot Page you will have to specify if your bot requires Privileged Intents. We recommend having these all enabled at first to ensure the most stability when building your first bot, otherwise you may run into issues when retrieving entities from the library's cache. Warning These privileged intents may not be available for you to toggle on immediately. Due to their nature of sensitive data, Discord requires you to go through a verification process once your bot is in a certain amount of servers. Please read this blog post for more information and how to apply. Discord Configuration Within your @DSharpPlus.DiscordConfiguration you will have to specify all the intents you will need. Here is a list of all the Intents DSharpPlus Supports. By default, the configuration will use @DSharpPlus.DiscordIntents.AllUnprivileged as the default value. Like above however, we recommend having all intents enabled at first, so you should specify @DSharpPlus.DiscordIntents.All in your configuration which will include the privleged intents you enabled in your application: var config = new DiscordConfiguration() { Intents = DiscordIntents.All }; When you become more advanced, you can try experimenting with turning off intents you do not need in order to save resources. In your @DSharpPlus.DiscordConfiguration you can specify one or many. Here is an example of just specifying one: var config = new DiscordConfiguration() { Intents = DiscordIntents.GuildMessages }; Here is an example of specifying many: var config = new DiscordConfiguration() { Intents = DiscordIntents.DirectMessageReactions | DiscordIntents.DirectMessages | DiscordIntents.GuildBans | DiscordIntents.GuildEmojis | DiscordIntents.GuildInvites | DiscordIntents.GuildMembers | DiscordIntents.GuildMessages | DiscordIntents.Guilds | DiscordIntents.GuildVoiceStates | DiscordIntents.GuildWebhooks, }; Please Note, if you specify a privileged intent within your @DSharpPlus.DiscordConfiguration that you have not signed up for on the Discord Application page, an error will be thrown on the connection."
  },
  "articles/beyond_basics/logging/default.html": {
    "href": "articles/beyond_basics/logging/default.html",
    "title": "The Default Logger | DSharpPlus",
    "keywords": "The Default Logger DSharpPlus ships with a default logging implementation which is enabled automatically with no setup required. This is a basic implementation that only sends log messages to the console. Minimum Logging Level You're able to adjust the verbosity of log messages via @DSharpPlus.DiscordConfiguration. new DiscordConfiguration() { MinimumLogLevel = LogLevel.Debug }; The example above will display level log messages that are higher than or equal to Debug. Timestamp Format You're also able to change the format of the log timestamp; this is also set through @DSharpPlus.DiscordConfiguration. new DiscordConfiguration() { LogTimestampFormat = \"MMM dd yyyy - hh:mm:ss tt\" }; For a list of all available format specifiers, check out the MSDN page for custom date and time format strings. Log Levels Below is a table of all log levels and the kind of messages you can expect from each. Name Position Description Critical 5 Fatal error which may require a restart. Error 4 A failure of an operation or request. Warning 3 Non-fatal errors and abnormalities. Information 2 Session startup and resume messages. Debug 1 Ratelimit buckets and related information. Trace 0 Websocket & REST traffic. Warning The Trace log level is not recommended for use in production. It is intended for debugging DSharpPlus and may display tokens and other sensitive data."
  },
  "articles/beyond_basics/logging/third_party.html": {
    "href": "articles/beyond_basics/logging/third_party.html",
    "title": "Third Party Logging | DSharpPlus",
    "keywords": "Using a Third Party Logger While the default logging implementation will meet the needs of most, some may desire to make use of a more robust implementation which provides more features. Thankfully, DSharpPlus allows you to use any logging library which has an implementation for the logging abstractions provided by Microsoft. Serilog, one of the more popular logging libraries, will be used to demonstrate. This will simply be a brief demo, so we won't go into the configuration of Serilog. You'll want to head on over to their wiki page to learn about that! We'll need to install both the Serilog and Serilog.Extensions.Logging packages from NuGet, along with at least one of the many available sinks. Our example here will only use the Serilog.Sinks.Console sink. Start off by creating a new LoggerConfiguration instance, slap .WriteTo.Console().CreateLogger() onto the end of it, then directly assign that to the static Logger property on the Log class. Log.Logger = new LoggerConfiguration() .WriteTo.Console() .CreateLogger(); This will make a new Serilog logger instance which will write to the console sink. Next, create a new variable and assign it a new LoggerFactory instance which calls AddSerilog(). var logFactory = new LoggerFactory().AddSerilog(); Then assign that variable to the @DSharpPlus.DiscordConfiguration.LoggerFactory property of your of @DSharpPlus.DiscordConfiguration. new DiscordConfiguration() { LoggerFactory = logFactory } Altogether, you'll have something similar to this: using Microsoft.Extensions.Logging; using Serilog; public async Task MainAsync() { Log.Logger = new LoggerConfiguration() .WriteTo.Console() .CreateLogger(); var logFactory = new LoggerFactory().AddSerilog(); var discord = new DiscordClient(new DiscordConfiguration() { LoggerFactory = logFactory }); } And that's it! If you now run your bot, you'll see DSharpPlus log messages formatted and displayed by Serilog."
  },
  "articles/beyond_basics/messagebuilder.html": {
    "href": "articles/beyond_basics/messagebuilder.html",
    "title": "Message Builder | DSharpPlus",
    "keywords": "Background Before the message builder was put into place, we had one large method for sending messages along with 3 additional methods for sending files. This was becoming a major code smell and it was hard to maintain and add more parameters onto it. Now we support just sending a simple message, an embed, a simple message with an embed, or a message builder. Using the Message Builder The API Documentation for the message builder can be found at @DSharpPlus.Entities.DiscordMessageBuilder but here we'll go over some of the concepts of using the message builder: Adding a File For sending files, you'll have to use the MessageBuilder to construct your message, see example below: using fs = new FileStream(\"ADumbFile.txt\", FileMode.Open, FileAccess.Read); var msg = await new DiscordMessageBuilder() .WithContent(\"Here is a really dumb file that I am testing with.\") .WithFiles(new Dictionary<string, Stream>() { { \"ADumbFile1.txt\", fs } }) .SendAsync(ctx.Channel); Adding Mentions For sending mentions, you'll have to use the MessageBuilder to construct your message, see example below: var msg = await new DiscordMessageBuilder() .WithContent($\"✔ UserMention(user): Hey, {user.Mention}! Listen!\") .WithAllowedMentions(new IMention[] { new UserMention(user) }) .SendAsync(ctx.Channel); Sending TTS Messages For sending a TTS message, you'll have to use the MessageBuilder to construct your message, see example below: var msg = await new DiscordMessageBuilder() .WithContent($\"This is a dumb message\") .HasTTS(true) .SendAsync(ctx.Channel); Sending an Inline Reply For sending an inline reply, you'll have to use the MessageBuilder to construct your message, see example below: var msg = await new DiscordMessageBuilder() .WithContent($\"I'm talking to *you*!\") .WithReply(ctx.Message.Id) .SendAsync(ctx.Channel); By default, replies do not mention. To make a reply mention, simply pass true as the second parameter: // ... .WithReply(ctx.Message.Id, true); // ..."
  },
  "articles/beyond_basics/sharding.html": {
    "href": "articles/beyond_basics/sharding.html",
    "title": "Sharding | DSharpPlus",
    "keywords": "Sharding As your bot joins more guilds, your poor @DSharpPlus.DiscordClient will be hit with an increasing number of events. Thankfully, Discord allows you to establish multiple connections to split the event workload; this is called sharding and each individual connection is referred to as a shard. Each shard handles a separate set of servers and will only receive events from those servers. However, all direct messages will be handled by your first shard. Sharding is recommended once you reach 1,000 servers, and is a requirement when you hit 2,500 servers. Automated Sharding DSharpPlus provides a built-in sharding solution: @DSharpPlus.DiscordShardedClient. This client will automatically spawn shards for you and manage their events. Each DSharpPlus extension (e.g. CommandsNext, Interactivity) also supplies an extension method to register themselves automatically on each shard. var discord = new DiscordShardedClient(new DiscordConfiguration { Token = \"My First Token\", TokenType = TokenType.Bot }); await discord.UseCommandsNextAsync(new CommandsNextConfiguration() { StringPrefixes = new[] { \"!\" } }); Manual Sharding For most looking to shard, the built-in @DSharpPlus.DiscordShardedClient will work well enough. However, those looking for more control over the sharding process may want to handle it manually. This would involve creating new @DSharpPlus.DiscordClient instances, assigning each one an appropriate shard ID number, and handling the events from each instance. Considering the potential complexity imposed by this process, you should only do this if you have a valid reason to do so and know what you are doing."
  },
  "articles/commands/argument_converters.html": {
    "href": "articles/commands/argument_converters.html",
    "title": "Argument Converter | DSharpPlus",
    "keywords": "Custom Argument Converter Writing your own argument converter will enable you to convert custom types and replace the functionality of existing converters. Like many things in DSharpPlus, doing this is straightforward and simple. First, create a new class which implements @DSharpPlus.CommandsNext.Converters.IArgumentConverter`1 and its method @DSharpPlus.CommandsNext.Converters.IArgumentConverter`1.ConvertAsync(System.String,DSharpPlus.CommandsNext.CommandContext). Our example will be a boolean converter, so we'll also pass bool as the type parameter for @DSharpPlus.CommandsNext.Converters.IArgumentConverter`1. public class CustomArgumentConverter : IArgumentConverter<bool> { public Task<Optional<bool>> ConvertAsync(string value, CommandContext ctx) { if (bool.TryParse(value, out var boolean)) { return Task.FromResult(Optional.FromValue(boolean)); } switch (value.ToLower()) { case \"yes\": case \"y\": case \"t\": return Task.FromResult(Optional.FromValue(true)); case \"no\": case \"n\": case \"f\": return Task.FromResult(Optional.FromValue(false)); default: return Task.FromResult(Optional.FromNoValue<bool>()); } } } Then register the argument converter with CommandContext. var discord = new DiscordClient(); var commands = discord.UseCommandsNext(); commands.RegisterConverter(new CustomArgumentConverter()); Once the argument converter is written and registered, we'll be able to use it: [Command(\"boolean\")] public async Task BooleanCommand(CommandContext ctx, bool boolean) { await ctx.RespondAsync($\"Converted to {boolean}\"); }"
  },
  "articles/commands/command_attributes.html": {
    "href": "articles/commands/command_attributes.html",
    "title": "Command Attributes | DSharpPlus",
    "keywords": "Built-In Attributes CommandsNext has a variety of built-in attributes to enhance your commands and provide some access control. The majority of these attributes can be applied to your command methods and command groups. @DSharpPlus.CommandsNext.Attributes.AliasesAttribute @DSharpPlus.CommandsNext.Attributes.CooldownAttribute @DSharpPlus.CommandsNext.Attributes.DescriptionAttribute @DSharpPlus.CommandsNext.Attributes.CategoryAttribute @DSharpPlus.CommandsNext.Attributes.DontInjectAttribute @DSharpPlus.CommandsNext.Attributes.HiddenAttribute @DSharpPlus.CommandsNext.Attributes.ModuleLifespanAttribute @DSharpPlus.CommandsNext.Attributes.PriorityAttribute @DSharpPlus.CommandsNext.Attributes.RemainingTextAttribute @DSharpPlus.CommandsNext.Attributes.RequireBotPermissionsAttribute @DSharpPlus.CommandsNext.Attributes.RequireDirectMessageAttribute @DSharpPlus.CommandsNext.Attributes.RequireGuildAttribute @DSharpPlus.CommandsNext.Attributes.RequireNsfwAttribute @DSharpPlus.CommandsNext.Attributes.RequireOwnerAttribute @DSharpPlus.CommandsNext.Attributes.RequirePermissionsAttribute @DSharpPlus.CommandsNext.Attributes.RequirePrefixesAttribute @DSharpPlus.CommandsNext.Attributes.RequireRolesAttribute @DSharpPlus.CommandsNext.Attributes.RequireUserPermissionsAttribute Custom Attributes If the above attributes don't meet your needs, CommandsNext also gives you the option of writing your own! Simply create a new class which inherits from @DSharpPlus.CommandsNext.Attributes.CheckBaseAttribute and implement the required method. Our example below will only allow a command to be ran during a specified year. public class RequireYearAttribute : CheckBaseAttribute { public int AllowedYear { get; private set; } public RequireYearAttribute(int year) { AllowedYear = year; } public override Task<bool> ExecuteCheckAsync(CommandContext ctx, bool help) { return Task.FromResult(AllowedYear == DateTime.Now.Year); } } You'll also need to apply the AttributeUsage attribute to your attribute. For our example attribute, we'll set it to only be usable once on methods. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class RequireYearAttribute : CheckBaseAttribute { // ... } You can provide feedback to the user using the @DSharpPlus.CommandsNext.CommandsNextExtension.CommandErrored event. private async Task Main(string[] args) { var discord = new DiscordClient(); var commands = discord.UseCommandsNext(); commands.CommandErrored += CmdErroredHandler; } private async Task CmdErroredHandler(CommandsNextExtension _, CommandErrorEventArgs e) { var failedChecks = ((ChecksFailedException)e.Exception).FailedChecks; foreach (var failedCheck in failedChecks) { if (failedCheck is RequireYearAttribute) { var yearAttribute = (RequireYearAttribute)failedCheck; await e.Context.RespondAsync($\"Only usable during year {yearAttribute.AllowedYear}.\"); } } } Once you've got all of that completed, you'll be able to use it on a command! [Command(\"generic\"), RequireYear(2030)] public async Task GenericCommand(CommandContext ctx, string generic) { await ctx.RespondAsync(\"Generic response.\"); }"
  },
  "articles/commands/command_handler.html": {
    "href": "articles/commands/command_handler.html",
    "title": "Custom Command Handler | DSharpPlus",
    "keywords": "Custom Command Handler Important Writing your own handler logic should only be done if you know what you're doing. You will be responsible for command execution and preventing deadlocks. Disable Default Handler To begin, we'll need to disable the default command handler provided by CommandsNext. This is done by setting the @DSharpPlus.CommandsNext.CommandsNextConfiguration.UseDefaultCommandHandler configuration property to false. var discord = new DiscordClient(); var commands = discord.UseCommandsNext(new CommandsNextConfiguration() { UseDefaultCommandHandler = false }); Create Event Handler We'll then write a new handler for the @DSharpPlus.DiscordClient.MessageCreated event fired from @DSharpPlus.DiscordClient. discord.MessageCreated += CommandHandler; // ... private Task CommandHandler(DiscordClient client, MessageCreateEventArgs e) { // See below ... } This event handler will be our command handler, and you'll need to write the logic for it. Handle Commands Start by parsing the message content for a prefix and command string var cnext = client.GetCommandsNext(); var msg = e.Message; // Check if message has valid prefix. var cmdStart = msg.GetStringPrefixLength(\"!\"); if (cmdStart == -1) return; // Retrieve prefix. var prefix = msg.Content.Substring(0, cmdStart); // Retrieve full command string. var cmdString = msg.Content.Substring(cmdStart); Then provide the command string to @DSharpPlus.CommandsNext.CommandsNextExtension.FindCommand*. var command = cnext.FindCommand(cmdString, out var args); Create a command context using our message and prefix, along with the command and its arguments var ctx = cnext.CreateContext(msg, prefix, command, args); And pass the context to @DSharpPlus.CommandsNext.CommandsNextExtension.ExecuteCommandAsync* to execute the command. _ = Task.Run(async () => await cnext.ExecuteCommandAsync(ctx)); // Wrapped in Task.Run() to prevent deadlocks. Finished Product Altogether, your implementation should function similarly to the following: private Task CommandHandler(DiscordClient client, MessageCreateEventArgs e) { var cnext = client.GetCommandsNext(); var msg = e.Message; var cmdStart = msg.GetStringPrefixLength(\"!\"); if (cmdStart == -1) return Task.CompletedTask; var prefix = msg.Content.Substring(0, cmdStart); var cmdString = msg.Content.Substring(cmdStart); var command = cnext.FindCommand(cmdString, out var args); if (command == null) return Task.CompletedTask; var ctx = cnext.CreateContext(msg, prefix, command, args); Task.Run(async () => await cnext.ExecuteCommandAsync(ctx)); return Task.CompletedTask; }"
  },
  "articles/commands/dependency_injection.html": {
    "href": "articles/commands/dependency_injection.html",
    "title": "Dependency Injection | DSharpPlus",
    "keywords": "Dependency Injection As you begin to write more complex commands, you'll find that you need a way to get data in and out of them. Although you could use static fields to accomplish this, the preferred solution would be dependency injection. This would involve placing all required object instances and types (referred to as services) in a container, then providing that container to CommandsNext. Each time a command module is instantiated, CommandsNext will then attempt to populate constructor parameters, public properties, and public fields exposed by the module with instances of objects from the service container - it is recommended you use constructor parameters for dependency injection. We'll go through a simple example of this process to help you understand better. Create a Service Provider To begin, we'll need to create a service provider; this will act as the container for the services you need for your commands. Create a new variable just before you register CommandsNext with your @DSharpPlus.DiscordClient and assign it a new instance of ServiceCollection. var discord = new DiscordClient(); var services = new ServiceCollection(); // Right here! var commands = discord.UseCommandsNext(); We'll use .AddSingleton to add type Random to the collection, then chain that call with the .BuildServiceProvider() extension method. The resulting type will be ServiceProvider. var services = new ServiceCollection() .AddSingleton<Random>() .BuildServiceProvider(); Then we'll need to provide CommandsNext with our services. var commands = discord.UseCommandsNext(new CommandsNextConfiguration() { Services = services }); Using Your Services Now that we have our services set up, we're able to use them in commands. We'll be tweaking our random number command to demonstrate. Add a new property to the command module named Rng. Make sure it has a public setter. public class MyFirstModule : BaseCommandModule { public Random Rng { private get; set; } // Implied public setter. // ... } Modify the random command to use our property. [Command(\"random\")] public async Task RandomCommand(CommandContext ctx, int min, int max) { await ctx.RespondAsync($\"Your number is: {Rng.Next(min, max)}\"); } Then we can give it a try! CommandsNext has automatically injected our singleton Random instance into the Rng property when our command module was instantiated. Now, for any command that needs Random, we can simply declare one as a property, field, or in the module constructor and CommandsNext will take care of the rest. Ain't that neat? Lifespans Modules By default, all command modules have a singleton lifespan; this means each command module is instantiated once for the lifetime of the CommandsNext instance. However, if the reuse of a module instance is undesired, you also have the option to change the lifespan of a module to transient using the @DSharpPlus.CommandsNext.Attributes.ModuleLifespanAttribute. [ModuleLifespan(ModuleLifespan.Transient)] public class MyFirstModule : BaseCommandModule { // ... } Transient command modules are instantiated each time one of its containing commands is executed. Services In addition to the .AddSingleton() extension method, you're also able to use the .AddScoped() and .AddTransient() extension methods to add services to the collection. The extension method chosen will affect when and how often the service is instantiated. Scoped and transient services should only be used in transient command modules, as singleton modules will always have their services injected once. Lifespan Instantiated Singleton One time when added to the collection. Scoped Once for each command module. Transient Each time its requested."
  },
  "articles/commands/help_formatter.html": {
    "href": "articles/commands/help_formatter.html",
    "title": "Help Formatter | DSharpPlus",
    "keywords": "Custom Help Formatter The built-in help command provided by CommandsNext is generated with a help formatter. This simple mechanism is given a command and its subcommands then returns a formatted help message. If you're not happy with the default help formatter, you're able to write your own and customize the output to your liking. Simply inherit from @DSharpPlus.CommandsNext.Converters.BaseHelpFormatter and provide an implementation for each of the required methods. public class CustomHelpFormatter : BaseHelpFormatter { // protected DiscordEmbedBuilder _embed; // protected StringBuilder _strBuilder; public CustomHelpFormatter(CommandContext ctx) : base(ctx) { // _embed = new DiscordEmbedBuilder(); // _strBuilder = new StringBuilder(); // Help formatters do support dependency injection. // Any required services can be specified by declaring constructor parameters. // Other required initialization here ... } public override BaseHelpFormatter WithCommand(Command command) { // _embed.AddField(command.Name, command.Description); // _strBuilder.AppendLine($\"{command.Name} - {command.Description}\"); return this; } public override BaseHelpFormatter WithSubcommands(IEnumerable<Command> cmds) { foreach (var cmd in cmds) { // _embed.AddField(cmd.Name, cmd.Description); // _strBuilder.AppendLine($\"{cmd.Name} - {cmd.Description}\"); } return this; } public override CommandHelpMessage Build() { // return new CommandHelpMessage(embed: _embed); // return new CommandHelpMessage(content: _strBuilder.ToString()); } } Alternatively, if you're only wanting to make a few small tweaks to the default help, you can write a simple help formatter which inherits from @DSharpPlus.CommandsNext.Converters.DefaultHelpFormatter and modify the inherited @DSharpPlus.CommandsNext.Converters.DefaultHelpFormatter.EmbedBuilder property. public class CustomHelpFormatter : DefaultHelpFormatter { public CustomHelpFormatter(CommandContext ctx) : base(ctx) { } public override CommandHelpMessage Build() { EmbedBuilder.Color = DiscordColor.SpringGreen; return base.Build(); } } Your final step is to register your help formatter with CommandsNext. var discord = new DiscordClient(); var commands = discord.UseCommandsNext(); commands.SetHelpFormatter<CustomHelpFormatter>(); That's all there is to it."
  },
  "articles/commands/intro.html": {
    "href": "articles/commands/intro.html",
    "title": "CommandsNext Introduction | DSharpPlus",
    "keywords": "Note This article assumes you've recently read the article on writing your first bot. Introduction to CommandsNext This article will introduce you to some basic concepts of our native command framework: CommandsNext. Be sure to install the DSharpPlus.CommandsNext package from NuGet before continuing. Writing a Basic Command Create a Command Module A command module is simply a class which acts as a container for your command methods. Instead of registering individual commands, you'd register a single command module which contains multiple commands. There's no limit to the amount of modules you can have, and no limit to the amount of commands each module can contain. For example: you could have a module for moderation commands and a separate module for image commands. This will help you keep your commands organized and reduce the clutter in your project. Our first demonstration will be simple, consisting of one command module with a simple command. We'll start by creating a new folder named Commands which contains a new class named MyFirstModule. Give this new class public access and have it inherit from BaseCommandModule. public class MyFirstModule : BaseCommandModule { } Create a Command Method Within our new module, create a method named GreetCommand marked as async with a Task return type. The first parameter of your method must be of type @DSharpPlus.CommandsNext.CommandContext, as required by CommandsNext. public async Task GreetCommand(CommandContext ctx) { } In the body of our new method, we'll use @DSharpPlus.CommandsNext.CommandContext.RespondAsync* to send a simple message. await ctx.RespondAsync(\"Greetings! Thank you for executing me!\"); Finally, mark your command method with the @DSharpPlus.CommandsNext.Attributes.CommandAttribute so CommandsNext will know to treat our method as a command method. This attribute takes a single parameter: the name of the command. We'll name our command greet to match the name of the method. [Command(\"greet\")] public async Task GreetCommand(CommandContext ctx) { await ctx.RespondAsync(\"Greetings! Thank you for executing me!\"); } Your command module should now resemble this: using System.Threading.Tasks; using DSharpPlus.CommandsNext; using DSharpPlus.CommandsNext.Attributes; public class MyFirstModule : BaseCommandModule { [Command(\"greet\")] public async Task GreetCommand(CommandContext ctx) { await ctx.RespondAsync(\"Greetings! Thank you for executing me!\"); } } Cleanup and Configuration Before we can run our new command, we'll need modify our main method. Start by removing the event handler we created previously. var discord = new DiscordClient(); discord.MessageCreated += async (s, e) => // REMOVE { // ALL if (e.Message.Content.ToLower().StartsWith(\"ping\")) // OF await e.Message.RespondAsync(\"pong!\"); // THESE }; // LINES await discord.ConnectAsync(); Next, call the @DSharpPlus.CommandsNext.ExtensionMethods.UseCommandsNext*extension method on your @DSharpPlus.DiscordClient instance and pass it a new @DSharpPlus.CommandsNext.CommandsNextConfiguration instance. Assign the resulting @DSharpPlus.CommandsNext.CommandsNextExtension instance to a new variable namedcommands. This important step will enable CommandsNext for your Discord client. var discord = new DiscordClient(); var commands = discord.UseCommandsNext(new CommandsNextConfiguration()); Create an object initializer for @DSharpPlus.CommandsNext.CommandsNextConfiguration and assign the @DSharpPlus.CommandsNext.CommandsNextConfiguration.StringPrefixes property a new string array containing your desired prefixes. Our example below will only define a single prefix: !. new CommandsNextConfiguration() { StringPrefixes = new[] { \"!\" } } Now we'll register our command module. Call the @DSharpPlus.CommandsNext.CommandsNextExtension.RegisterCommands* method on our @DSharpPlus.CommandsNext.CommandsNextExtension instance and provide it with your command module. var discord = new DiscordClient(); var commands = discord.UseCommandsNext(); commands.RegisterCommands<MyFirstModule>(); await discord.ConnectAsync(); Alternatively, you can pass in your assembly to register commands from all modules in your program. commands.RegisterCommands(Assembly.GetExecutingAssembly()); Your main method should look similar to the following: static async Task Main(string[] args) { var discord = new DiscordClient(new DiscordConfiguration()); var commands = discord.UseCommandsNext(new CommandsNextConfiguration() { StringPrefixes = new[] { \"!\" } }); commands.RegisterCommands<MyFirstModule>(); await discord.ConnectAsync(); await Task.Delay(-1); } Running Your Command It's now the moment of truth; all your blood, sweat, and tears have lead to this moment. Hit F5 on your keyboard to compile and run your bot, then execute your command in any channel that your bot account has access to. That was easy. Taking User Input Command Arguments Now that we have a basic command down, let's spice it up a bit by defining arguments to accept user input. Defining an argument is simple; just add additional parameters to your signature of your command method. CommandsNext will automatically parse user input and populate the parameters of your command method with those arguments. To demonstrate, we'll modify our greet command to greet a user with a given name. Head back to MyFirstModule and add a parameter of type string to the GreetCommand method. [Command(\"greet\")] public async Task GreetCommand(CommandContext ctx, string name) CommandsNext will now interpret this as a command named greet that takes one argument. Next, replace our original response message with an interpolated string which uses our new parameter. public async Task GreetCommand(CommandContext ctx, string name) { await ctx.RespondAsync($\"Greetings, {name}! You're pretty neat!\"); } That's all there is to it. Smack F5 and test it out in a channel your bot account has access to. Now, you may have noticed that providing more than one word simply does not work. For example, !greet Luke Smith will result in no response from your bot. This fails because a valid overload could not be found for your command. CommandsNext will split arguments by whitespace. This means Luke Smith is counted as two separate arguments; Luke and Smith. In addition to this, CommandsNext will attempt to find and execute an overload of your command that has the same number of provided arguments. Together, this means that any additional arguments will prevent CommandsNext from finding a valid overload to execute. The simplest way to get around this would be to wrap your input with double quotes. CommandsNext will parse this as one argument, allowing your command to be executed. !greet \"Luke Smith\" If you would prefer not to use quotes, you can use the @DSharpPlus.CommandsNext.Attributes.RemainingTextAttribute attribute on your parameter. This attribute will instruct CommandsNext to parse all remaining arguments into that parameter. public async Task GreetCommand(CommandContext ctx, [RemainingText] string name) Alternatively, you can use the params keyword to have all remaining arguments parsed into an array. public async Task GreetCommand(CommandContext ctx, params string[] names) A more obvious solution is to add additional parameters to the method signature of your command method. public async Task GreetCommand(CommandContext ctx, string firstName, string lastName) Each of these has their own caveats; it'll be up to you to choose the best solution for your commands. Argument Converters CommandsNext can convert arguments, which are natively string, to the type specified by a command method parameter. This functionality is powered by argument converters, and it'll help to eliminate the boilerplate code needed to parse and convert string arguments. CommandsNext has built-in argument converters for the following types: Category Types Discord DiscordGuild, DiscordChannel, DiscordMember, DiscordUser, DiscordRole, DiscordMessage, DiscordEmoji, DiscordColor Integral byte, short, int, long, sbyte, ushort, uint, ulong Floating-Point float, double, decimal Date DateTime, DateTimeOffset, TimeSpan Character string, char Boolean bool You're also able to create and provide your own custom argument converters, if desired. Let's do a quick demonstration of the built-in converters. Create a new command method above our GreetCommand method named RandomCommand and have it take two integer arguments. As the method name suggests, this command will be named random. [Command(\"random\")] public async Task RandomCommand(CommandContext ctx, int min, int max) { } Make a variable with a new instance of Random. var random = new Random(); Finally, we'll respond with a random number within the range provided by the user. await ctx.RespondAsync($\"Your number is: {random.Next(min, max)}\"); Run your bot once more with F5 and give this a try in a text channel. CommandsNext converted the two arguments from string into int and passed them to the parameters of our command, removing the need to manually parse and convert the arguments yourself. We'll do one more to drive the point home. Head back to our old GreetCommand method, remove our name parameter, and replace it with a new parameter of type @DSharpPlus.Entities.DiscordMember named member. public async Task GreetCommand(CommandContext ctx, DiscordMember member) Then modify the response to mention the provided member with the @DSharpPlus.Entities.DiscordUser.Mention property on @DSharpPlus.Entities.DiscordMember. public async Task GreetCommand(CommandContext ctx, DiscordMember member) { await ctx.RespondAsync($\"Greetings, {member.Mention}! Enjoy the mention!\"); } Go ahead and give that a test run. The argument converter for @DSharpPlus.Entities.DiscordMember is able to parse mentions, usernames, nicknames, and user IDs then look for a matching member within the guild the command was executed from. Ain't that neat? Command Overloads Command method overloading allows you to create multiple argument configurations for a single command. [Command(\"foo\")] public Task FooCommand(CommandContext ctx, string bar, int baz) { } [Command(\"foo\")] public Task FooCommand(CommandContext ctx, DiscordUser bar) { } Executing !foo green 5 will run the first method, and !foo @Emzi0767 will run the second method. Additionally, all check attributes are shared between overloads. [Command(\"foo\"), Aliases(\"bar\", \"baz\")] [RequireGuild, RequireBotPermissions(Permissions.AttachFiles)] public Task FooCommand(CommandContext ctx, int bar, int baz, string qux = \"agony\") { } [Command(\"foo\")] public Task FooCommand(CommandContext ctx, DiscordChannel bar, TimeSpan baz) { } The additional attributes and checks applied to the first method will also be applied to the second method. Further Reading Now that you've gotten an understanding of CommandsNext, it'd be a good idea check out the following: Command Attributes Help Formatter Dependency Injection"
  },
  "articles/hosting.html": {
    "href": "articles/hosting.html",
    "title": "Hosting Solutions | DSharpPlus",
    "keywords": "24/7 Hosting Solutions Free hosting If you're looking for free hosts, you've likely considered using Heroku or Glitch. We advise against using these platforms as they are designed to host web services, not Discord bots, and instances from either of these companies will shut down if there isn't enough internet traffic. Save yourself the headache and don't bother. Alternatively, some providers are offering Free Tiers which also allow application hosting. These services typically have some sort of resource quota, and may charge money on exceeding these quotas. Make sure to carefully review the fine-print, and understand that these services may come with strings attached. You can find examples below. Self Hosting If you have access to an unused machine, have the technical know-how, and you also have a solid internet connection, you might consider hosting your bot on your own. Even if you don't have a spare PC on hand, parts to build one are fairly cheap in most regions. You could think of it as a one time investment with no monthly server fees. Any modern hardware will work just fine, new or used. Depending on how complex your bot is, you may even consider purchasing a Raspberry Pi ($35). Third-Party Hosting The simplest, and probably most hassle-free (and maybe cheapest in the long run for dedicated machines) option is to find a provider that will lend you their machine or a virtual host so you can run your bot in there. Generally, cheapest hosting options are all GNU/Linux-based, so it's highly recommended you familiarize yourself with the OS and its environment, particularly the shell (command line), and concepts such as SSH. There are several well-known, trusted, and cheap providers: Xenyth Cloud - A hosting solution made by Discord bot developers. Based in Canada, starting from $2.49/mo. Vultr - Based in the US with datacenters in many regions, including APAC. Starting at $2.50/mo. DigitalOcean - The gold standard, US based. Locations available world wide. Starting from $5.00/mo. Linode - US based host with many datacenters around the world. Starting at $5.00/mo. OVH - Very popular VPS host. Worldwide locations available. Starting from $6.00/mo. Contabo - Based in Germany, US locations available; extremely good value for the price. Starting from 4.99€/mo. Things to keep in mind when looking for a hosting provider: The majority of cheap VPS hosts will be running some variant of Linux, and not Windows. The primary Discord API server is located in East US. If latency matters for you application, choose a provider who is closer to this location. In addition to these, there are several hosting providers who offer free tiers, free trials, or in-service credit: Microsoft Azure: $200 in-service credit, to be used within month of registration. There are also several always-free services available, including various compute resources. Requires credit or debit card for validation. Azure isn't cheap, but it supports both Windows and GNU/Linux-based servers. If you're enrolled in Microsoft Imagine, it's possible to get these cheaper or free. Amazon Web Services: Free for 12 months (with 750 compute hours per month), with several always-free options available. Not cheap once the trial runs out, but it's also considered industry standard in cloud services. Google Cloud Platform: $300 in-service credit, to be used within year of registration, and several always-free resources available, albeit with heavy restrictions. GCP is based in the US, and offers very scalable products. Like the above, it's not the cheapest of offerings. Oracle Cloud - $300 credit to be used within a month, and an always-free tier, which provides up to 4 ARM cores, 24GB of ram, and 200GB of storage in compute resources, as well as some small x64 instances. There is no monthly time limit. This service does require a valid credit card and offers no SLA. Hosting on Cloud Native Services With most bots, unless if you host many of them, they dont require a whole machine to run them, just a slice of a machine. This is where Docker and other cloud native hosting comes into play. There are many different options available to you and you will need to chose which one will suit you best. Here are a few services that offer Docker or other cloud native solutions that are cheaper than running a whole VM. Azure App Service: Allows for Hosting Website, Continous Jobs, and Docker images on a Windows base or Linux base machine. AWS Fargate: Allows for hosting Docker images within Amazon Web Services. Jelastic: Allows for hosting Docker images. Making your publishing life easier Now that we have covered where you can possibly host your application, now lets cover how to make your life easier publishing it. Many different source control solutions out there are free and also offer some type of CI/CD integration (paid and free). Below are some of the solutions that we recommend: Github: Offers Git repository hosting, as well as static page hosting (under *.github.io domain) and basic CI/CD in form of GitHub actions. GitLab: Another Git repository hosting, offers a far more advanced and flexible CI/CD. Can be self-hosted. BitBucket: Like the previous two, offers Git repository hosting, and CI/CD services. Azure Devops: Offers Git and Team Foundation Version Control repository hosting, in addition to full CI/CD pipeline, similar to GitHub actions. The CI/CD offering can be attached to other services as well."
  },
  "articles/interactivity.html": {
    "href": "articles/interactivity.html",
    "title": "Interactivity Introduction | DSharpPlus",
    "keywords": "Introduction to Interactivity Interactivity will enable you to write commands which the user can interact with through reactions and messages. The goal of this article is to introduce you to the general flow of this extension. Make sure to install the DSharpPlus.Interactivity package from NuGet before continuing. Enabling Interactivity Interactivity can be registered using the @DSharpPlus.Interactivity.Extensions.ClientExtensions.UseInteractivity(DSharpPlus.DiscordClient,DSharpPlus.Interactivity.InteractivityConfiguration) extension method. Optionally, you can also provide an instance of @DSharpPlus.Interactivity.InteractivityConfiguration to modify default behaviors. var discord = new DiscordClient(); discord.UseInteractivity(new InteractivityConfiguration() { PollBehaviour = PollBehaviour.KeepEmojis, Timeout = TimeSpan.FromSeconds(30) }); Using Interactivity There are two ways available to use interactivity: Extension methods available for @DSharpPlus.Entities.DiscordChannel and @DSharpPlus.Entities.DiscordMessage. Instance methods available from @DSharpPlus.Interactivity.InteractivityExtension. We'll have a quick look at a few common interactivity methods along with an example of use for each. The first (and arguably most useful) extension method is @DSharpPlus.Interactivity.InteractivityExtension.SendPaginatedMessageAsync* for @DSharpPlus.Entities.DiscordChannel This method displays a collection of 'pages' which are selected one-at-a-time by the user through reaction buttons. Each button click will move the page view in one direction or the other until the timeout is reached. You'll need to create a collection of pages before you can invoke this method. This can be done easily using the @DSharpPlus.Interactivity.InteractivityExtension.GeneratePagesInEmbed*and @DSharpPlus.Interactivity.InteractivityExtension.GeneratePagesInContent* instance methods from @DSharpPlus.Interactivity.InteractivityExtension. Alternatively, for pre-generated content, you can create and add individual instances of @DSharpPlus.Interactivity.Page to a collection. This example will use the @DSharpPlus.Interactivity.InteractivityExtension.GeneratePagesInEmbed* method to generate the pages. public async Task PaginationCommand(CommandContext ctx) { var reallyLongString = \"Lorem ipsum dolor sit amet, consectetur adipiscing ...\" var interactivity = ctx.Client.GetInteractivity(); var pages = interactivity.GeneratePagesInEmbed(reallyLongString); await ctx.Channel.SendPaginatedMessageAsync(ctx.Member, pages); } Next we'll look at the @DSharpPlus.Interactivity.Extensions.MessageExtensions.WaitForReactionAsync* extension method for @DSharpPlus.Entities.DiscordMessage. This method waits for a reaction from a specific user and returns the emoji that was used. An overload of this method also enables you to wait for a specific reaction, as shown in the example below. public async Task ReactionCommand(CommandContext ctx, DiscordMember member) { var emoji = DiscordEmoji.FromName(ctx.Client, \":ok_hand:\"); var message = await ctx.RespondAsync($\"{member.Mention}, react with {emoji}.\"); var result = await message.WaitForReactionAsync(member, emoji); if (!result.TimedOut) await ctx.RespondAsync(\"Thank you!\"); } Another reaction extension method for @DSharpPlus.Entities.DiscordMessage is @DSharpPlus.Interactivity.InteractivityExtension.CollectReactionsAsync* As the name implies, this method collects all reactions on a message until the timeout is reached. public async Task CollectionCommand(CommandContext ctx) { var message = await ctx.RespondAsync(\"React here!\"); var reactions = await message.CollectReactionsAsync(); var strBuilder = new StringBuilder(); foreach (var reaction in reactions) { strBuilder.AppendLine($\"{reaction.Emoji}: {reaction.Total}\"); } await ctx.RespondAsync(strBuilder.ToString()); } The final one we'll take a look at is the @DSharpPlus.Interactivity.Extensions.ChannelExtensions.GetNextMessageAsync* extension method for @DSharpPlus.Entities.DiscordMessage. This method will return the next message sent from the author of the original message. Our example here will use its alternate overload which accepts an additional predicate. public async Task ActionCommand(CommandContext ctx) { await ctx.RespondAsync(\"Respond with *confirm* to continue.\"); var result = await ctx.Message.GetNextMessageAsync(m => { return m.Content.ToLower() == \"confirm\"; }); if (!result.TimedOut) await ctx.RespondAsync(\"Action confirmed.\"); }"
  },
  "articles/migration/2x_to_3x.html": {
    "href": "articles/migration/2x_to_3x.html",
    "title": "Migration 2.x - 3.x | DSharpPlus",
    "keywords": "Migration From 2.x to 3.x Major breaking changes: Most classes were organized into namespaces. Several classes and methods were renamed to maintain consistency with the rest of the library. All events were renamed to be in the past tense. @DSharpPlus.Entities.DiscordEmbed instances are no longer constructed directly. Instead, they are built using a @DSharpPlus.Entities.DiscordEmbedBuilder. All colors are now passed as instances of @DSharpPlus.Entities.DiscordColor. Command modules are now based on an abstract class rather than an interface. A brand-new ratelimit handler has been implemented. Fixing namespace issues Entities such as @DSharpPlus.Entities.DiscordUser, @DSharpPlus.Entities.DiscordChannel, and similar are in the @DSharpPlus.Entities namespace, exceptions in @DSharpPlus.Exceptions, event arguments in @DSharpPlus.EventArgs, and network components in @DSharpPlus.Net. Be sure to add these namespaces to your using directives as needed. Class, Method, and Event Renames Several classes and methods were renamed to fit the current naming scheme in the library. 2.x 3.x DiscordConfig DiscordConfiguration CommandExecutedEventArgs CommandExecutionEventArgs SnowflakeObject.CreationDate SnowflakeObject.CreationTimestamp VoiceReceivedEventArgs VoiceReceiveEventArgs DiscordMessage.EditAsync() DiscordMessage.ModifyAsync() SocketDisconnectEventArgs SocketCloseEventArgs DiscordMember.TakeRoleAsync() DiscordMember.RevokeRoleAsync() MessageReactionRemoveAllEventArgs MessageReactionsClearEventArgs Additionally, all events received a rename to maintain consistent naming across the library with many receiving an d or ed to the end of their name. Embed woes Embeds can no longer be constructed or modified directly. Instead, you have to use the embed builder. For the most part, this can be achieved using Find/Replace and doing new DiscordEmbed -> new DiscordEmbedBuilder. On top of that, to add fields to an embed, you no longer create a new list for fields and assign it to @DSharpPlus.Entities.DiscordEmbedBuilder.Fields, but instead you use the @DSharpPlus.Entities.DiscordEmbedBuilder.AddField* method on the builder. To modify an existing embed, pass said embed to builder's constructor. The builder will use it as a prototype. Color changes This one is easy to fix for the most part. For situation where you were doing e.g. Color = 0xC0FFEE, you now do Color = new DiscordColor(0xC0FFEE). This has the added advantage of letting you create a color from 3 RGB values or parse an RGB string. Default channel removal DefaultChannel no longer exists on guilds, and, as such, DiscordGuild.CreateInviteAsync() is also gone, as it relied on that property. The new concept of \"default\" channel is a fallback, and is basically top channel the user can see. In the library this is facilitated via DiscordGuild.GetDefaultChannel(). Module changes The IModule interface was removed, and replaced with BaseModule class. The most notable change is that your module should no longer define the field which holds your instance of @DSharpPlus.DiscordClient, as that's on the base class itself. On top of that, you need to change modifiers of .Setup() from public to protected internal override. New ratelimit handler This does not actually cause any in-code changes, however the behavior of the REST client and the way requests are handled changes drastically. The new handler is thread-safe, and uses queueing to handle REST requests, and should bucket requests properly now."
  },
  "articles/migration/3x_to_4x.html": {
    "href": "articles/migration/3x_to_4x.html",
    "title": "Migration 3.x - 4.x | DSharpPlus",
    "keywords": "Migration From 3.x to 4.x Proxy Support The client now supports proxies for both WebSocket and HTTP traffic. To proxy your traffic, create a new instance of System.Net.WebProxy and assign it to @DSharpPlus.DiscordConfiguration.Proxy property. Module Rename 3.x 4.x CommandsNextModule CommandsNextExtension InteractivityModule InteractivityExtension VoiceNextClient VoiceNextExtension BaseModule BaseExtension Intents Due to a change by Discord on their V8 endpoint which DSharpPlus targets, in order to recieve events, intents will have to be enabled in both the @DSharpPlus.DiscordConfiguration and the Discord Application Portal. We have an article that covers all that has to be done to set this up. Event Handlers The signitures for all the event handlers have changed to have 2 parameters instead of one. Please refer to this article for the changes. Entity mutation changes Entity updating methods now take an action which mutates the state of the object, instead of taking large lists of arguments. This means that instead of updating e.g. a role like this: await role.UpdateAsync(name: \"Modified Role\", color: new DiscordColor(0xFF00FF)); you will update it like this: await role.UpdateAsync(x => { x.Name = \"Modified Role\"; x.Color = new DiscordColor(0xFF00FF); }); SendMessageAsync and SendFileAsync Methods We now have a message builder that will handle any advanced creating and modifing of messages. Below are the overloads for sending and modifing messages: Sending Messages .SendMessageAsync(DiscordChannel, DiscordEmbed) .SendMessageAsync(DiscordChannel, System.String) .SendMessageAsync(DiscordChannel, System.String,DiscordEmbed) .SendMessageAsync(DiscordChannel, DiscordMessageBuilder) Modifying Messages DiscordMessage.ModifyAsync(DSharpPlus.Entities.Optional<DSharpPlus.Entities.DiscordEmbed>) DiscordMessage.ModifyAsync(DSharpPlus.Entities.Optional<string>) DiscordMessage.ModifyAsync(DSharpPlus.Entities.Optional<string>, DSharpPlus.Entities.Optional<DSharpPlus.Entities.DiscordEmbed>) DiscordMessage.ModifyAsync(DSharpPlus.Entities.DiscordMessageBuilder) Using the @DSharpPlus.Entities.DiscordMessageBuilder can be found here. Logging Changes Logging was overhauled and now some of the Properties on @DSharpPlus.DiscordConfiguration along with some of the events on @DSharpPlus.DiscordClient are Gone/Modified/Added. Below is a listing of what changed: **@DSharpPlus.DiscordConfiguration.LoggerFactory** - this is where you can specify your own logging factory to help augment the output of the log messages, redirect the output to other locations, etc. **@DSharpPlus.DiscordConfiguration.MinimumLogLevel** - this replaces LogLevel DebugLogger - this has been removed. UseInternalLogHandler - this has been removed. DebugLogMessageEventArgs - this event has been removed. We have also created an article on how to setup the new logger. Other minor changes User DM handling - Users can no longer be DM'd directly. Instead, you will need to find a member object for the user you want to DM, then use the appropriate methods on the member object. Channel permission override enhancements - You can now query the member or role objects for each permission override set on channels. Furthermore, the overwrite building is now more intuitive. Indefinite reconnecting - the client can now be configured to attempt reconnecting indefinitely. Channel.Users - you can now query users in voice and text channels by using @DSharpPlus.Entities.DiscordChannel.Users property. SendFileAsync argument reordering - arguments for these methods were reordered to prevent overload confusion. New Discord features - support for animated emoji and slow mode. CommandsNext There were several major changes made to CommandsNext extension. While basics remain the same, some finer details are different. Multiprefix support Prefixes are now configured via @DSharpPlus.CommandsNext.CommandsNextConfiguration.StringPrefixes instead of old StringPrefix property. Prefixes passed in this array will all function at the same time. At the same time, @DSharpPlus.CommandsNext.CommandContext class has been augmented with @DSharpPlus.CommandsNext.CommandContext.Prefix property, which allows for checking which prefix was used to trigger the command. Furthermore, the new @DSharpPlus.CommandsNext.Attributes.RequirePrefixesAttribute can be used as a check to require a specific prefix to be used with a command. Command hiding inheritance Much like checks, the @DSharpPlus.CommandsNext.Attributes.HiddenAttribute is now inherited in modules which are not command groups. Support for Nullable<T> and System.Uri conversion The default argument converters have been augmented to allow for conversion of nullable value types. No further configuration is required. Furthermore, native support for System.Uri type now exists as well. Dependency Injection changes CommandsNext now uses Microsoft's Dependency Injection abstractions, which greatly enhances flexibility, as well as allows 3rd party service containers to be used. For more information, see Dependency injection page. Command overloads and group commands Command overloads are now implemented. This means you can create a command which takes multiple various argument type configurations. This is done by creating several commands and giving them all the same name. Overloads need to have unique argument configurations, which means that it is possible to create commands which use the same argument types in different order (e.g. int, string and string, int), however you cannot create two overloads which have the same argument types and order. Checks are pooled between all overloads, which means that specifying the same check on every overload will make it run several times; if you apply a check to a single overload, it will apply to all of them. Group command is also done by marking a command with @DSharpPlus.CommandsNext.Attributes.GroupCommandAttribute instead of regular CommandAttribute. They can also be overloaded. Common module base All command modules are now required to inherit from @DSharpPlus.CommandsNext.BaseCommandModule. This also enables the modules to use @DSharpPlus.CommandsNext.BaseCommandModule.BeforeExecutionAsync(DSharpPlus.CommandsNext.CommandContext) and @DSharpPlus.CommandsNext.BaseCommandModule.AfterExecutionAsync(DSharpPlus.CommandsNext.CommandContext). Module lifespans It is now possible to create transient command modules. As opposed to regular singleton modules, which are instantiated upon registration, these modules are instantiated before every command call, and are disposed shortly after. Combined with dependency injection changes, this enables the usage of transient and scoped modules. For more information, see Module lifespans page. Help formatter changes Help formatter is now lower level, because it now receives a command object and a group object. Furthermore, they are now also subject to dependency injection, receiving services and command context via DI. Default help module is also transient, allowing it to take advantage of more advanced DI usages. If you need to implement a custom help formatter, see Custom Help Formatter. Custom command handlers You can now disabe the built-in command handler, and create your own. For more information, see Custom Command Handlers. Minor changes Case-insensitivity changes - case insensitivity now applies to command name matching, prefix matching, and argument conversions. DM help - Default help can now be routed to DMs. Custom attributes on commands - CommandsNext now exposes all custom attributes declared on commands, groups, and modules. Implicit naming - Commands can be named from their method or class name, by not giving it a name in the Command or Group attribute. Argument converters are now asynchronous - this allows using async code in converters. Interactivity Interactivity went through an extensive rewrite and many methods were changed: Method Change CollectReactionsAsync Different return value CreatePollAsync Changed to DoPollAsync. SendPaginatedMessage Changed to SendPaginatedMessageAsync. GeneratePagesInEmbeds New parameter. GeneratePagesInStrings New parameter. GeneratePaginationReactions Removed. DoPagination Removed. WaitForMessageReactionAsync Changed to WaitForReactionAsync. WaitForTypingUserAsync Changed to WaitForUserTypingAsync. WaitForTypingChannelAsync Changed to WaitForTypingAsync. VoiceNext VoiceNext went through a substantial rewrite. Below are some of the key highlights: Implemented support for Voice Gateway v4 Implemented support for lite and suffix encryption mode Improved performance Replaced old voice sending API with new stream-based transmit API that is non-blocking and has built-in support for Changing volume levels. Automatic sending of silence packets on connection to enable incoming voice Incoming voice now properly maintains an Opus decoder per source Packet loss is now concealed via Opus FEC (if possible) or silence packets VoiceNext will now properly send and process UDP keepalive packets UDP and WebSocket ping values are now exposed on VoiceNextConnection objects Voice OP12 and 13 (user join and leave respectively) are now supported and exposed on VoiceNextConnection objects. Lavalink The library now comes with a Lavalink client, which supports both Lavalink 2.x and 3.x. Lavalink is a standalone lightweight Java application, which handles downloading, transcoding, and transmitting audio to Discord. For more information, see the Lavalink article."
  },
  "articles/migration/dsharp.html": {
    "href": "articles/migration/dsharp.html",
    "title": "Migration From DiscordSharp | DSharpPlus",
    "keywords": "Migration From DiscordSharp Connecting // Old. var discord = new DiscordClient(\"My First Token\", true); discord.SendLoginRequest(); discord.Connect(); The constructor of the @DSharpPlus.DiscordClient now requires a @DSharpPlus.DiscordConfiguration object instead of a simple string token and boolean. // New. var discord = new DiscordClient(new DiscordConfiguration { Token = \"your token\", TokenType = TokenType.Bot }); await discord.ConnectAsync(); await Task.Delay(-1); New versions of DSharpPlus implement TAP, and the all DSharpPlus methods ending with async will need to be awaited within an asynchronous method. Events While the signature will look similar, many changes have been done to events behind the scenes. discord.MessageReceived += async (sender, arg) => { // Code here }; We have a small article covering DSharpPlus events here. New events ChannelPinsUpdated ClientErrored GuildEmojisUpdated GuildIntegrationsUpdated GuildMembersChunked GuildRoleCreated GuildUnavailable Heartbeated MessageAcknowledged MessageReactionAdded MessageReactionRemoved MessageReactionsCleared MessagesBulkDeleted SocketErrored UnknownEvent UserSettingsUpdated VoiceServerUpdated WebhooksUpdated Removed Events TextClientDebugMessageReceived VoiceClientDebugMessageReceived Changed Event names Old DiscordSharp Event DSharpPlus Equivalent MessageReceived MessageCreated Connected Ready PrivateChannelCreated DmChannelCreated PrivateMessageReceived MessageCreated MentionReceived MessageCreated UserTypingStart TypingStarted MessageEdited MessageUpdated URLMessageAutoUpdate MessageUpdate VoiceStateUpdate VoiceStateUpdated UserUpdate UserUpdated UserAddedToServer GuildMemberAdded UserRemovedFromServer GuildMemberRemoved RoleDeleted GuildRoleDeleted RoleUpdated GuildRoleUpdated GuildMemberBanned GuildBanAdded PrivateChannelDeleted DMChannelDeleted BanRemoved GuildBanRemoved PrivateMessageDeleted MessageDeleted."
  },
  "articles/misc/debug_symbols.html": {
    "href": "articles/misc/debug_symbols.html",
    "title": "Debug Symbols | DSharpPlus",
    "keywords": "I want to diagnose a problem I believe originates from the library, how do? In the event you need to debug DSharpPlus, we offer debug symbols. They are available at the following locations: Symbol sources All of our symbols can be found on Nuget. Nightly builds have symbols and source included inside of the packages, while release builds will only contain the symbols. Using the symbols In Visual Studio: Go to Tools > Options > Debugging and make sure \"Just My Code\" is disabled and \"Source Server Support\" is enabled. Go to Tools > Options > Debugging > Symbols, and add the URL in there."
  },
  "articles/misc/nightly_builds.html": {
    "href": "articles/misc/nightly_builds.html",
    "title": "Nightly Builds | DSharpPlus",
    "keywords": "I like living on the edge - give me the freshest builds We offer nightly builds for DSharpPlus. They contain bugfixes and new features before the stable releases, however they are not guaranteed to be stable, or work at all. Simply open the NuGet interface for your project, check Prerelease and select Latest prerelease version of the DSharpPlus packages, and install them. If you find any problems in the nightly versions of the packages, please follow the instructions in Reporting issues article. Additionally, take care to not use 5.0.0 nightly builds. They are not currently production- or development-ready. 4.x.x nightly builds are currently more up-to-date and more stable, as work on v5 is still in earliest stages and is not currently made available via nightly builds."
  },
  "articles/misc/reporting_issues.html": {
    "href": "articles/misc/reporting_issues.html",
    "title": "Reporting Issues | DSharpPlus",
    "keywords": "I broke something, and I need it fixed We always try to fix bugs, and make sure that when we release the next version of DSharpPlus, everything is polished and working. However, DSharpPlus is a large codebase, and we can't always catch all the bugs, or notice all the regressions that happen while we fix bugs or implement new issues. GitHub issue tracker If you find a bug, come up with a new idea, or just want to report something, you can open an issue on our GitHub Issue Tracker. When opening an issue, make sure to include as much detail as possible. If at all possible, please include: Steps to reproduce the issue What were you trying to achieve Expected/acutal result Stack traces, exception types, messages Attempted solutions Discord Some questions, most notably questions on using the library, are better asked on Discord. You can find the server links on the preamble. Make sure to ask for help in the #! help-and-support! forum. Contributing Lastly, while we understand that not everyone is an expert programmer, we would appreciate it if you could fix any issues you find and submit a Pull Request on GitHub. This would reduce the amount of work we would have to do. When contributing, ensure your code matches the style of the rest of the library, and that you test the changes you make, and catch any possible regressions."
  },
  "articles/preamble.html": {
    "href": "articles/preamble.html",
    "title": "Article Preamble | DSharpPlus",
    "keywords": "Knowledge Prerequisites Before attempting to write a Discord bot, you should be familiar with the concepts of Object Oriented Programing, the C# programming language, and Task-based Asynchronous Pattern. If you're brand new to C#, or programming in general, this library may prove difficult for you to use. Fortunately, there are resources that can help you get started with the language! An excellent tutorial series to go through would be C# Fundamentals for Absolute Beginners by Bob Tabor. His videos go through all the basics, from setting up your development environment up to some of the more advanced concepts. If you're not sure what to do first, Bob's tutorial series should be your starting point! Supported .NET Implementations Because DSharpPlus targets .NET Standard 2.0, there are many implementations that may function with DSharpPlus. However, there are only a few versions we will explicitly provide support for. Implementation Support Notes .NET ✔️ EoL versions Core 3.1 and 5.0 should work; LTS version 6.0 and STS version 7.0 are supported. .NET Framework ⚠️ Versions 4.6.1 through 4.8 should work fine. However, we do not directly support .NET Framework. We recommend that you use the latest or LTS version of .NET Core. Mono ❌️ Has numerous flaws which can break things without warning. If you need a cross platform runtime, use .NET. Unity ❌️ Game engines with C# support will never be supported by DSharpPlus. You should consider using the official Discord GameSDK instead. If you use an unsupported implementation and encounter issues, you'll be on your own. Getting Started If you're writing a Discord bot for the first time, you'll want to start with creating a bot account. Otherwise, if you have a bot account already, start off with the writing your first bot article. Once you're up and running, feel free to browse through the API Documentation! Support and Questions You can get in contact with us on Discord through one of the following guilds: DSharpPlus Guild: #dotnet_dsharpplus on Discord API:"
  },
  "articles/slash_commands.html": {
    "href": "articles/slash_commands.html",
    "title": "Slash Commands | DSharpPlus",
    "keywords": "Slash Commands Introduction This is the documentation for the slash commands extension for DSharpPlus (it also supports context menus). This is a direct merge of IDoEverything's slash command extension, so if you've been using that one you shouldn't need to make any changes in your code. There are some caveats to the usage of the library that you should note: It does not support registering or editing commands at runtime. While you can make commands at runtime using the methods on the client, if you have a command class registered for that guild/globally if you're making global commands, it will be overwritten (therefore probably deleted) on the next startup due to the limitations of the bulk overwrite endpoint. If your usage of slash commands depends on dynamically registering commands, this extension will not work for you. Important: Authorizing your bot For a bot to make slash commands in a server, it must be authorized with the applications.commands scope as well. In the OAuth2 section of the developer portal, you can check the applications.commands box to generate an invite link. You can check the bot box as well to generate a link that authorizes both. If a bot is already authorized with the bot scope, you can still authorize with just the applications.commands scope without having to kick out the bot. If your bot isn't properly authorized, a 403 exception will be thrown on startup. Setup Add the using reference to your bot class: using DSharpPlus.SlashCommands; You can then register a SlashCommandsExtension on your DiscordClient, similar to how you register a CommandsNextExtension var slash = discord.UseSlashCommands(); Making a command class Similar to CommandsNext, you can make a module for slash commands and make it inherit from ApplicationCommandModule public class SlashCommands : ApplicationCommandModule { //commands } You have to then register it with your SlashCommandsExtension. Slash commands can be registered either globally or for a certain guild. However, if you try to register them globally, they can take up to an hour to cache across all guilds. So, it is recommended that you only register them for a certain guild for testing, and only register them globally once they're ready to be used. To register your command class, //To register them for a single server, recommended for testing slash.RegisterCommands<SlashCommands>(guild_id); //To register them globally, once you're confident that they're ready to be used by everyone slash.RegisterCommands<SlashCommands>(); Make sure that you register them before your ConnectAsync Making Slash Commands On to the exciting part. Slash command methods must be Tasks and have the SlashCommand attribute. The first argument for the method must be an InteractionContext. Let's make a simple slash command: public class SlashCommands : ApplicationCommandModule { [SlashCommand(\"test\", \"A slash command made to test the DSharpPlusSlashCommands library!\")] public async Task TestCommand(InteractionContext ctx) { } } To make a response, you must run CreateResponseAsync on your InteractionContext. CreateResponseAsync takes two arguments. The first is a InteractionResponseType: DeferredChannelMessageWithSource - Acknowledges the interaction, doesn't require any content. ChannelMessageWithSource - Sends a message to the channel, requires you to specify some data to send. An interaction expires in 3 seconds unless you make a response. If the code you execute before making a response has the potential to take more than 3 seconds, you should first create a DeferredChannelMessageWithSource response, and then edit it after your code executes. The second argument is a type of DiscordInteractionResponseBuilder. It functions similarly to the DiscordMessageBuilder, except you cannot send files, and you can have multiple embeds. If you want to send a file, you'll have to edit the response. A simple response would be like: [SlashCommand(\"test\", \"A slash command made to test the DSharpPlus Slash Commands extension!\")] public async Task TestCommand(InteractionContext ctx) { await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(\"Success!\")); } If your code will take some time to execute: [SlashCommand(\"delaytest\", \"A slash command made to test the DSharpPlus Slash Commands extension!\")] public async Task DelayTestCommand(InteractionContext ctx) { await ctx.CreateResponseAsync(InteractionResponseType.DeferredChannelMessageWithSource); //Some time consuming task like a database call or a complex operation await ctx.EditResponseAsync(new DiscordWebhookBuilder().WithContent(\"Thanks for waiting!\")); } You can also override BeforeExecutionAsync and AfterExecutionAsync to run code before and after all the commands in a module. This does not apply to groups, you have the override them individually for the group's class. BeforeExecutionAsync can also be used to prevent the command from running. Arguments If you want the user to be able to give more data to the command, you can add some arguments. Arguments must have the Option attribute, and can be of type: string long or long? bool or bool? double or double? DiscordUser - This can be cast to DiscordMember if the command is run in a guild DiscordChannel DiscordRole DiscordAttachment SnowflakeObject - This can accept both a user and a role; you can cast it DiscordUser, DiscordMember or DiscordRole to get the actual object Enum - This can used for choices through an enum; read further If you want to make them optional, you can assign a default value. You can also predefine some choices for the option. Custom choices only work for string, long or double arguments (for DiscordChannel arguments, ChannelTypes attribute can be used to limit the types of channels that can be chosen). There are several ways to use them: Using the Choice attribute. You can add multiple attributes to add multiple choices. You can define choices using enums. See the example below. You can use a ChoiceProvider to run code to get the choices from a database or similar. See the example below. (second and third method contributed by @Epictek) Some examples: //Attribute choices [SlashCommand(\"ban\", \"Bans a user\")] public async Task Ban(InteractionContext ctx, [Option(\"user\", \"User to ban\")] DiscordUser user, [Choice(\"None\", 0)] [Choice(\"1 Day\", 1)] [Choice(\"1 Week\", 7)] [Option(\"deletedays\", \"Number of days of message history to delete\")] long deleteDays = 0) { await ctx.Guild.BanMemberAsync(user.Id, (int)deleteDays); await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent($\"Banned {user.Username}\")); } //Enum choices public enum MyEnum { [ChoiceName(\"Option 1\")] option1, [ChoiceName(\"Option 2\")] option2, [ChoiceName(\"Option 3\")] option3 } [SlashCommand(\"enum\", \"Test enum\")] public async Task EnumCommand(InteractionContext ctx, [Option(\"enum\", \"enum option\")]MyEnum myEnum = MyEnum.option1) { await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(myEnum.GetName())); } //ChoiceProvider choices public class TestChoiceProvider : IChoiceProvider { public async Task<IEnumerable<DiscordApplicationCommandOptionChoice>> Provider() { return new DiscordApplicationCommandOptionChoice[] { //You would normally use a database call here new DiscordApplicationCommandOptionChoice(\"testing\", \"testing\"), new DiscordApplicationCommandOptionChoice(\"testing2\", \"test option 2\") }; } } [SlashCommand(\"choiceprovider\", \"test\")] public async Task ChoiceProviderCommand(InteractionContext ctx, [ChoiceProvider(typeof(TestChoiceProvider))] [Option(\"option\", \"option\")] string option) { await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent(option)); } Groups You can have slash commands in groups. Their structure is explained here. You can simply mark your command class with the [SlashCommandGroup] attribute. //for regular groups [SlashCommandGroup(\"group\", \"description\")] public class GroupContainer : ApplicationCommandModule { [SlashCommand(\"command\", \"description\")] public async Task Command(InteractionContext ctx) {} [SlashCommand(\"command2\", \"description\")] public async Task Command2(InteractionContext ctx) {} } //For subgroups inside groups [SlashCommandGroup(\"group\", \"description\")] public class SubGroupContainer : ApplicationCommandModule { [SlashCommandGroup(\"subgroup\", \"description\")] public class SubGroup : ApplicationCommandModule { [SlashCommand(\"command\", \"description\")] public async Task Command(InteractionContext ctx) {} [SlashCommand(\"command2\", \"description\")] public async Task Command2(InteractionContext ctx) {} } [SlashCommandGroup(\"subgroup2\", \"description\")] public class SubGroup2 : ApplicationCommandModule { [SlashCommand(\"command\", \"description\")] public async Task Command(InteractionContext ctx) {} [SlashCommand(\"command2\", \"description\")] public async Task Command2(InteractionContext ctx) {} } } Context Menus Context menus are commands that show up when you right click on a user or a message. Their implementation is fairly similar to slash commands. //For user commands [ContextMenu(ApplicationCommandType.UserContextMenu, \"User Menu\")] public async Task UserMenu(ContextMenuContext ctx) { } //For message commands [ContextMenu(ApplicationCommandType.MessageContextMenu, \"Message Menu\")] public async Task MessageMenu(ContextMenuContext ctx) { } Responding works exactly the same as slash commands. You cannot define any arguments. Pre-execution checks You can define some custom attributes that function as pre-execution checks, working very similarly to CommandsNext. Simply create an attribute that inherits SlashCheckBaseAttribute for slash commands, and ContextMenuCheckBaseAttribute for context menus and override the methods. There are also some built in ones for slash commands, the same ones as on CommandsNext but prefix with Slash - for example the SlashRequirePermissionsAttribute public class RequireUserIdAttribute : SlashCheckBaseAttribute { public ulong UserId; public RequireUserIdAttribute(ulong userId) { this.UserId = userId; } public override async Task<bool> ExecuteChecksAsync(InteractionContext ctx) { if (ctx.User.Id == UserId) return true; else return false; } } Then just apply it to your command [SlashCommand(\"admin\", \"runs sneaky admin things\")] [RequireUserId(0000000000000)] public async Task Admin(InteractionContext ctx) { //secrets } To provide a custom error message when an execution check fails, hook the SlashCommandErrored event for slash commands, and ContextMenuErrored event for context menus on your SlashCommandsExtension SlashCommandsExtension slash = //assigned; slash.SlashCommandErrored += async (s, e) => { if(e.Exception is SlashExecutionChecksFailedException slex) { foreach (var check in slex.FailedChecks) if (check is RequireUserIdAttribute att) await e.Context.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent($\"Only <@{att.Id}> can run this command!\")); } }; Context menus throw ContextMenuExecutionChecksFailedException. To use a built in one: [SlashCommand(\"ban\", \"Bans a user\")] [SlashRequirePermissions(Permissions.BanMembers)] public async Task Ban(InteractionContext ctx, [Option(\"user\", \"User to ban\")] DiscordUser user, [Choice(\"None\", 0)] [Choice(\"1 Day\", 1)] [Choice(\"1 Week\", 7)] [Option(\"deletedays\", \"Number of days of message history to delete\")] long deleteDays = 0) { await ctx.Guild.BanMemberAsync(user.Id, (int)deleteDays); await ctx.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new DiscordInteractionResponseBuilder().WithContent($\"Banned {user.Username}\")); } Dependency Injection To pass in a service collection, provide a SlashCommandsConfiguration in UseSlashCommands. var slash = discord.UseSlashCommands(new SlashCommandsConfiguration { Services = new ServiceCollection().AddSingleton<Random>().BuildServiceProvider() }); Property injection is implemented, however static properties will not be replaced. If you wish for a non-static property to be left alone, assign it the DontInject attribute. Property Injection can be used like so: public class Commands : ApplicationCommandModule { public Database Database { private get; set; } // The get accessor is optionally public, but the set accessor must be public. [SlashCommand(\"ping\", \"Checks the latency between the bot and it's database. Best used to see if the bot is lagging.\")] public async Task Ping(InteractionContext context) => await context.CreateResponseAsync(InteractionResponseType.ChannelMessageWithSource, new() { Content = $\"Pong! Database latency is {Database.GetPing()}ms.\" }); } Sharding UseSlashCommands -> UseSlashCommmandsAsync which returns a dictionary. You'll have to foreach over it to register events. Module Lifespans You can specify a module's lifespan by applying the SlashModuleLifespan attribute on it. Modules are transient by default."
  },
  "faq.html": {
    "href": "faq.html",
    "title": "Frequently Asked Questions | DSharpPlus",
    "keywords": "Frequently Asked Questions I've updated from an old version to the latest version and my project won't build! Please read the latest migration article to see a list of changes, as major version releases will usually have several breaking changes. Code I copied from an article isn't compiling or working as expected. Why? Please use the code snippets as a reference; don't blindly copy-paste code! The snippets of code in the articles are meant to serve as examples to help you understand how to use a part of the library. Although most will compile and work at the time of writing, changes to the library over time can make some snippets obsolete. Many issues can be resolved with Intellisense by searching for similarly named methods and verifying method parameters. I'm targeting Mono and have exceptions, crashes, or other problems. As mentioned in the preamble, the Mono runtime is inherently unstable and has numerous flaws. Because of this we do not support Mono in any way, nor will we support any other projects which use it. Instead, we recommend using either the latest LTS release or most recent stable version of .NET. Connecting to a voice channel with VoiceNext will either hang or throw an exception. To troubleshoot, please ensure that: You are using the latest version of DSharpPlus. You have properly enabled VoiceNext with your instance of @DSharpPlus.DiscordClient. You are not using VoiceNext in an event handler. You have opus and libsodium available in your target environment. Why am I getting heartbeat skipped message in my console? There are two possible reasons: Connection issue between your bot application and Discord. Check your internet connection and ensure that the machine your bot is hosted on has a stable internet connection. If your local network has no issues, the problem could be with either Discord or Cloudfare. In which case, it's out of your control. Complex, long-running code in an event handler. Any event handlers that have the potential to run for more than a few seconds could cause a deadlock, and cause several heartbeats to be skipped. Please take a look at our short article on handling DSharpPlus exceptions to learn how to avoid this. Why am I getting a 4XX error and how can I fix it? HTTP Error Code Cause Resolution 401 Invalid token. Verify your token and make sure no errors were made. The client secret found on the 'general information' tab of your application page is not your token. 403 Not enough permissions. Verify permissions and ensure your bot account has a role higher than the target user. Administrator permissions do not bypass the role hierarchy. 404 Requested object not found. This usually means the entity does not exist. You should reattempt then inform your user. I cannot modify a specific user or role. Why is this? In order to modify a user, the highest role of your bot account must be higher than the target user. Changing the properties of a role requires that your bot account have a role higher than that role. Does CommandsNext support dependency injection? It does! Please take a look at our article on the subject. Can I use a user token? Automating a user account is against Discord's Terms of Service and is not supported by DSharpPlus. How can I set a custom status? If you mean a true custom status like this: No, you cannot. Discord does not allow bots to use custom statuses. However, if you meant an activity like this: You can use either of the following The overload for @DSharpPlus.DiscordClient.UpdateStatusAsync(DSharpPlus.Entities.DiscordActivity,System.Nullable{DSharpPlus.Entities.UserStatus},System.Nullable{System.DateTimeOffset}) which accepts a @DSharpPlus.Entities.DiscordActivity. The overload for @DSharpPlus.DiscordClient.UpdateStatusAsync(DSharpPlus.Entities.DiscordActivity,System.Nullable{DSharpPlus.Entities.UserStatus},System.Nullable{System.DateTimeOffset}) OR @DSharpPlus.DiscordShardedClient.UpdateStatusAsync(DSharpPlus.Entities.DiscordActivity,System.Nullable{DSharpPlus.Entities.UserStatus},System.Nullable{System.DateTimeOffset}) (for the sharded client) at any point after Ready has been fired. Am I able to retrieve a @DSharpPlus.Entities.DiscordRole by name? Yes. Use LINQ on the @DSharpPlus.Entities.DiscordGuild.Roles property of your instance of @DSharpPlus.Entities.DiscordGuild and compare against the @DSharpPlus.Entities.DiscordRole.Name of each @DSharpPlus.Entities.DiscordRole. Why are you using Newtonsoft.Json when <xref:System.Text.Json> is available? Yes, <xref:System.Text.Json> is available to use, and we aim to use <xref:System.Text.Json> in DSharpPlus v5. Because of the large effort associated with switching, v4 will continue to use Newtonsoft.Json Why the hell are my events not firing? This is because since version 8 of the Discord API, @DSharpPlus.DiscordIntents are required to be enabled on @DSharpPlus.DiscordConfiguration and the Discord Application Portal. We have an article that covers all that has to be done to set this up. Where are my pictures of spiderman?"
  },
  "index.html": {
    "href": "index.html",
    "title": "DSharpPlus Documentation | DSharpPlus",
    "keywords": "DSharpPlus Documentation DSharpPlus (D#+) is an unofficial .NET wrapper for the Discord API which was originally a fork of DiscordSharp. The library has since been rewritten to fit quality and API standards as well as target modern .NET implementations. Getting Started New users will want to take a look through the articles for quick start guides, tutorials, and examples of use. Once you've gotten through the articles, head on over to the API Documentation for all classes and methods provided by this library. Source and Contributors DSharpPlus is licensed under MIT License, as detailed in the license found in the repository. The repository containing the source code for this library can be found here. Contributions are welcomed. DSharpPlus is built by Naamloos, Emzi0767, Axiom, afroraydude, DrCreo, TiaqoY0, Neuheit, SSG/Maxine, and many others..."
  },
  "natives/index.html": {
    "href": "natives/index.html",
    "title": "Native Libraries | DSharpPlus",
    "keywords": "Downloads Operating System Download Checksums GPG Signatures 64-bit Windows Click Here Click Here Click Here 32-bit Windows Click Here Click Here Click Here Signatures use key 246AB92A3C22030A. Licenses Library License Opus https://opus-codec.org/license/ libsodium https://github.com/jedisct1/libsodium/blob/master/LICENSE"
  }
}